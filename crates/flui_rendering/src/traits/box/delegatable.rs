//! Delegatable traits for ambassador-based delegation.
//!
//! These traits are marked with `#[delegatable_trait]` to enable automatic
//! method forwarding via the `#[derive(Delegate)]` macro.
//!
//! # Usage
//!
//! ```rust,ignore
//! use ambassador::Delegate;
//! use flui_rendering::traits::box::{ProxyBoxBehavior, ambassador_impl_ProxyBoxBehavior};
//!
//! #[derive(Delegate)]
//! #[delegate(ProxyBoxBehavior, target = "proxy")]
//! pub struct RenderOpacity {
//!     proxy: ProxyBox,
//!     opacity: f32,
//! }
//! ```

use ambassador::delegatable_trait;

// Re-export the macro generated by #[delegatable_trait]
// This is needed for #[derive(Delegate)] to work in other modules
pub use ambassador::delegatable_trait_remote;
use flui_types::{Offset, Size};

use crate::constraints::BoxConstraints;
use crate::pipeline::PaintingContext;

use super::{BoxHitTestResult, RenderBox};

// ============================================================================
// ProxyBoxBehavior - delegatable trait for proxy boxes
// ============================================================================

/// Delegatable trait for proxy box behavior.
///
/// This trait defines the common interface for render objects that
/// pass through to a single child. By marking it with `#[delegatable_trait]`,
/// render objects can use `#[derive(Delegate)]` to automatically forward
/// all methods to their container field.
///
/// # Methods
///
/// All methods have default implementations that delegate to the child.
/// Override specific methods to customize behavior.
///
/// # Example
///
/// ```rust,ignore
/// #[derive(Delegate)]
/// #[delegate(ProxyBoxBehavior, target = "proxy")]
/// pub struct RenderOpacity {
///     proxy: ProxyBox,
///     opacity: f32,
/// }
///
/// // Only override paint - everything else delegates to proxy
/// impl RenderOpacity {
///     fn custom_paint(&self, context: &mut PaintingContext, offset: Offset) {
///         if self.opacity > 0.0 {
///             context.push_opacity(self.opacity, |ctx| {
///                 self.proxy.paint(ctx, offset);
///             });
///         }
///     }
/// }
/// ```
#[delegatable_trait]
pub trait ProxyBoxBehavior {
    /// Returns the child render box, if any.
    fn proxy_child(&self) -> Option<&dyn RenderBox>;

    /// Returns mutable access to the child render box, if any.
    fn proxy_child_mut(&mut self) -> Option<&mut dyn RenderBox>;

    /// Returns whether a child is present.
    fn proxy_has_child(&self) -> bool {
        self.proxy_child().is_some()
    }

    /// Returns the cached size.
    fn proxy_size(&self) -> Size;

    /// Performs layout by delegating to the child.
    ///
    /// Returns child's size or `constraints.smallest()` if no child.
    fn proxy_perform_layout(&mut self, constraints: BoxConstraints) -> Size;

    /// Paints by delegating to the child.
    fn proxy_paint(&self, context: &mut PaintingContext, offset: Offset);

    /// Hit tests by delegating to the child.
    fn proxy_hit_test_children(&self, result: &mut BoxHitTestResult, position: Offset) -> bool;

    /// Computes minimum intrinsic width.
    fn proxy_compute_min_intrinsic_width(&self, height: f32) -> f32 {
        self.proxy_child()
            .map(|c| c.compute_min_intrinsic_width(height))
            .unwrap_or(0.0)
    }

    /// Computes maximum intrinsic width.
    fn proxy_compute_max_intrinsic_width(&self, height: f32) -> f32 {
        self.proxy_child()
            .map(|c| c.compute_max_intrinsic_width(height))
            .unwrap_or(0.0)
    }

    /// Computes minimum intrinsic height.
    fn proxy_compute_min_intrinsic_height(&self, width: f32) -> f32 {
        self.proxy_child()
            .map(|c| c.compute_min_intrinsic_height(width))
            .unwrap_or(0.0)
    }

    /// Computes maximum intrinsic height.
    fn proxy_compute_max_intrinsic_height(&self, width: f32) -> f32 {
        self.proxy_child()
            .map(|c| c.compute_max_intrinsic_height(width))
            .unwrap_or(0.0)
    }

    /// Computes dry layout (size without side effects).
    fn proxy_compute_dry_layout(&self, constraints: BoxConstraints) -> Size {
        self.proxy_child()
            .map(|c| c.compute_dry_layout(constraints))
            .unwrap_or_else(|| constraints.smallest())
    }
}

// ============================================================================
// Implementation for ProxyBox
// ============================================================================

use crate::containers::ProxyBox;

impl ProxyBoxBehavior for ProxyBox {
    fn proxy_child(&self) -> Option<&dyn RenderBox> {
        self.child()
    }

    fn proxy_child_mut(&mut self) -> Option<&mut dyn RenderBox> {
        self.child_mut()
    }

    fn proxy_size(&self) -> Size {
        self.size()
    }

    fn proxy_perform_layout(&mut self, constraints: BoxConstraints) -> Size {
        let size = if let Some(child) = self.child_mut() {
            child.perform_layout(constraints)
        } else {
            constraints.smallest()
        };
        self.set_geometry(size);
        size
    }

    fn proxy_paint(&self, context: &mut PaintingContext, offset: Offset) {
        if let Some(child) = self.child() {
            context.paint_child(child, offset);
        }
    }

    fn proxy_hit_test_children(&self, result: &mut BoxHitTestResult, position: Offset) -> bool {
        self.hit_test_child(result, position)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_proxy_box_implements_behavior() {
        let proxy = ProxyBox::new();
        assert!(!proxy.proxy_has_child());
        assert_eq!(proxy.proxy_size(), Size::ZERO);
    }

    #[test]
    fn test_proxy_box_dry_layout() {
        let proxy = ProxyBox::new();
        let constraints = BoxConstraints::new(0.0, 100.0, 0.0, 100.0);
        let size = proxy.proxy_compute_dry_layout(constraints);
        assert_eq!(size, Size::ZERO); // No child, returns smallest
    }
}
