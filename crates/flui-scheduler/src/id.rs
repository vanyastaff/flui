//! Type-safe identifiers using PhantomData markers
//!
//! This module provides generic ID types that use phantom type parameters
//! to prevent mixing different kinds of identifiers at compile time.
//!
//! ## PhantomData Pattern
//!
//! PhantomData allows us to "tag" types with additional type information
//! without any runtime cost. This prevents bugs like passing a TaskId
//! where a FrameId is expected.
//!
//! ```rust
//! use flui_scheduler::id::{TypedId, FrameIdMarker, TaskIdMarker};
//!
//! type FrameId = TypedId<FrameIdMarker>;
//! type TaskId = TypedId<TaskIdMarker>;
//!
//! fn process_frame(id: FrameId) { /* ... */ }
//!
//! let frame_id = FrameId::new();
//! let task_id = TaskId::new();
//!
//! process_frame(frame_id);  // OK
//! // process_frame(task_id);  // Compile error!
//! ```

use std::fmt;
use std::hash::Hash;
use std::marker::PhantomData;
use std::num::NonZeroU64;
use std::sync::atomic::{AtomicU64, Ordering};

// =============================================================================
// ID Marker Traits (Sealed)
// =============================================================================

mod sealed {
    pub trait IdMarkerSealed {}

    impl IdMarkerSealed for super::FrameIdMarker {}
    impl IdMarkerSealed for super::TaskIdMarker {}
    impl IdMarkerSealed for super::TickerIdMarker {}
    impl IdMarkerSealed for super::CallbackIdMarker {}
}

/// Marker trait for ID types - sealed to prevent external implementations
///
/// # Sealed Trait
///
/// This trait is **sealed** and cannot be implemented outside of this crate.
/// The available ID markers are:
/// - [`FrameIdMarker`]
/// - [`TaskIdMarker`]
/// - [`TickerIdMarker`]
/// - [`CallbackIdMarker`]
pub trait IdMarker: sealed::IdMarkerSealed + Send + Sync + 'static {
    /// Human-readable name for this ID type
    const NAME: &'static str;
}

/// Marker for frame identifiers
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FrameIdMarker;

impl IdMarker for FrameIdMarker {
    const NAME: &'static str = "Frame";
}

/// Marker for task identifiers
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TaskIdMarker;

impl IdMarker for TaskIdMarker {
    const NAME: &'static str = "Task";
}

/// Marker for ticker identifiers
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TickerIdMarker;

impl IdMarker for TickerIdMarker {
    const NAME: &'static str = "Ticker";
}

/// Marker for callback identifiers
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CallbackIdMarker;

impl IdMarker for CallbackIdMarker {
    const NAME: &'static str = "Callback";
}

// =============================================================================
// TypedId - Generic ID with Phantom Type
// =============================================================================

/// A type-safe identifier with compile-time type checking
///
/// Uses `NonZeroU64` for niche optimization - `Option<TypedId<M>>` is the same
/// size as `TypedId<M>` (8 bytes).
///
/// ## Example
///
/// ```rust
/// use flui_scheduler::id::{TypedId, FrameIdMarker, TaskIdMarker};
///
/// // Create type aliases for clarity
/// type FrameId = TypedId<FrameIdMarker>;
/// type TaskId = TypedId<TaskIdMarker>;
///
/// let frame = FrameId::new();
/// let task = TaskId::new();
///
/// // These are different types - can't be mixed!
/// assert_ne!(std::any::TypeId::of::<FrameId>(), std::any::TypeId::of::<TaskId>());
/// ```
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TypedId<M: IdMarker> {
    value: NonZeroU64,
    _marker: PhantomData<M>,
}

impl<M: IdMarker> TypedId<M> {
    /// Create a new unique ID
    ///
    /// IDs are generated using a global atomic counter, ensuring uniqueness
    /// across all IDs of the same type within a process.
    ///
    /// # Panics
    ///
    /// Panics if the internal counter overflows (after 2^64 - 1 IDs).
    /// In practice, this is effectively impossible.
    pub fn new() -> Self {
        static COUNTER: AtomicU64 = AtomicU64::new(1);
        let value = COUNTER.fetch_add(1, Ordering::Relaxed);

        Self {
            // SAFETY: Counter starts at 1 and only increments
            value: NonZeroU64::new(value).expect("ID counter overflow"),
            _marker: PhantomData,
        }
    }

    /// Create from a raw value
    ///
    /// This is not marked `unsafe` because using a non-unique ID cannot cause
    /// memory unsafety, only logical errors. However, callers should ensure:
    ///
    /// - The value is unique within its usage domain
    /// - The ID was not already generated by another source
    ///
    /// # Use Cases
    ///
    /// - Deserializing IDs from storage
    /// - Interoperating with external ID systems
    pub const fn from_raw(value: NonZeroU64) -> Self {
        Self {
            value,
            _marker: PhantomData,
        }
    }

    /// Get the raw value
    #[inline]
    pub const fn raw(self) -> NonZeroU64 {
        self.value
    }

    /// Get the raw value as u64
    #[inline]
    pub const fn as_u64(self) -> u64 {
        self.value.get()
    }

    /// Get the marker type name
    #[inline]
    pub const fn type_name() -> &'static str {
        M::NAME
    }
}

impl<M: IdMarker> Default for TypedId<M> {
    fn default() -> Self {
        Self::new()
    }
}

impl<M: IdMarker> fmt::Debug for TypedId<M> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}Id({})", M::NAME, self.value)
    }
}

impl<M: IdMarker> fmt::Display for TypedId<M> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}#{}", M::NAME, self.value)
    }
}

// =============================================================================
// Type Aliases for Common ID Types
// =============================================================================

/// Type-safe frame identifier
pub type TypedFrameId = TypedId<FrameIdMarker>;

/// Type-safe task identifier
pub type TypedTaskId = TypedId<TaskIdMarker>;

/// Type-safe ticker identifier
pub type TypedTickerId = TypedId<TickerIdMarker>;

/// Type-safe callback identifier
pub type TypedCallbackId = TypedId<CallbackIdMarker>;

// =============================================================================
// ID Generation with Custom Counters
// =============================================================================

/// ID generator for a specific marker type
///
/// Useful when you need deterministic ID generation or want to reset counters.
pub struct IdGenerator<M: IdMarker> {
    counter: AtomicU64,
    _marker: PhantomData<M>,
}

impl<M: IdMarker> IdGenerator<M> {
    /// Create a new ID generator starting from 1
    pub const fn new() -> Self {
        Self {
            counter: AtomicU64::new(1),
            _marker: PhantomData,
        }
    }

    /// Create a generator starting from a specific value
    ///
    /// If `start` is 0, it will be set to 1 to ensure non-zero IDs.
    pub fn starting_from(start: u64) -> Self {
        let start = if start == 0 { 1 } else { start };
        Self {
            counter: AtomicU64::new(start),
            _marker: PhantomData,
        }
    }

    /// Generate the next ID
    ///
    /// # Panics
    ///
    /// Panics if the counter overflows (after 2^64 - 1 IDs).
    pub fn next(&self) -> TypedId<M> {
        let value = self.counter.fetch_add(1, Ordering::Relaxed);
        TypedId {
            value: NonZeroU64::new(value).expect("ID counter overflow"),
            _marker: PhantomData,
        }
    }

    /// Get the current counter value (next ID that will be generated)
    pub fn current(&self) -> u64 {
        self.counter.load(Ordering::Relaxed)
    }

    /// Reset the counter to 1
    pub fn reset(&self) {
        self.counter.store(1, Ordering::Relaxed);
    }
}

impl<M: IdMarker> Default for IdGenerator<M> {
    fn default() -> Self {
        Self::new()
    }
}

// =============================================================================
// Handle Pattern (ID + Generation for ABA problem prevention)
// =============================================================================

/// A handle that includes a generation number
///
/// Useful for detecting stale references in slot-map style data structures.
/// The generation is incremented each time a slot is reused.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Handle<M: IdMarker> {
    index: u32,
    generation: u32,
    _marker: PhantomData<M>,
}

impl<M: IdMarker> Handle<M> {
    /// Create a new handle
    pub const fn new(index: u32, generation: u32) -> Self {
        Self {
            index,
            generation,
            _marker: PhantomData,
        }
    }

    /// Get the index
    #[inline]
    pub const fn index(self) -> u32 {
        self.index
    }

    /// Get the generation
    #[inline]
    pub const fn generation(self) -> u32 {
        self.generation
    }

    /// Create a handle with incremented generation (for slot reuse)
    #[inline]
    pub const fn next_generation(self) -> Self {
        Self {
            index: self.index,
            generation: self.generation.wrapping_add(1),
            _marker: PhantomData,
        }
    }

    /// Pack into a single u64 for efficient storage
    #[inline]
    pub const fn pack(self) -> u64 {
        ((self.generation as u64) << 32) | (self.index as u64)
    }

    /// Unpack from a u64
    #[inline]
    pub const fn unpack(packed: u64) -> Self {
        Self {
            index: packed as u32,
            generation: (packed >> 32) as u32,
            _marker: PhantomData,
        }
    }
}

impl<M: IdMarker> fmt::Debug for Handle<M> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}Handle({}, gen={})",
            M::NAME,
            self.index,
            self.generation
        )
    }
}

impl<M: IdMarker> fmt::Display for Handle<M> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}[{}:{}]", M::NAME, self.index, self.generation)
    }
}

/// Type-safe frame handle
pub type FrameHandle = Handle<FrameIdMarker>;

/// Type-safe task handle
pub type TaskHandle = Handle<TaskIdMarker>;

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_typed_id_uniqueness() {
        let id1 = TypedFrameId::new();
        let id2 = TypedFrameId::new();

        assert_ne!(id1, id2);
        assert!(id2.as_u64() > id1.as_u64());
    }

    #[test]
    fn test_typed_id_type_safety() {
        // This is a compile-time test - these types are different
        let _frame_id: TypedFrameId = TypedId::new();
        let _task_id: TypedTaskId = TypedId::new();

        // Type names are different
        assert_eq!(TypedFrameId::type_name(), "Frame");
        assert_eq!(TypedTaskId::type_name(), "Task");
    }

    #[test]
    fn test_typed_id_display() {
        let frame_id = TypedFrameId::new();
        let display = format!("{}", frame_id);
        assert!(display.starts_with("Frame#"));
    }

    #[test]
    fn test_option_niche_optimization() {
        use std::mem::size_of;

        // NonZeroU64 enables niche optimization
        assert_eq!(size_of::<TypedFrameId>(), 8);
        assert_eq!(size_of::<Option<TypedFrameId>>(), 8);
    }

    #[test]
    fn test_id_generator() {
        let gen = IdGenerator::<FrameIdMarker>::new();

        let id1 = gen.next();
        let id2 = gen.next();
        let id3 = gen.next();

        assert_eq!(id1.as_u64(), 1);
        assert_eq!(id2.as_u64(), 2);
        assert_eq!(id3.as_u64(), 3);

        gen.reset();
        let id4 = gen.next();
        assert_eq!(id4.as_u64(), 1);
    }

    #[test]
    fn test_handle() {
        let handle = FrameHandle::new(42, 1);

        assert_eq!(handle.index(), 42);
        assert_eq!(handle.generation(), 1);

        let next = handle.next_generation();
        assert_eq!(next.index(), 42);
        assert_eq!(next.generation(), 2);
    }

    #[test]
    fn test_handle_pack_unpack() {
        let original = TaskHandle::new(12345, 67890);
        let packed = original.pack();
        let unpacked = TaskHandle::unpack(packed);

        assert_eq!(original.index(), unpacked.index());
        assert_eq!(original.generation(), unpacked.generation());
    }
}
