//! InheritedWidget - widgets that propagate data down the tree
//!
//! InheritedWidgets allow data to be efficiently shared with descendant widgets.
//! When an InheritedWidget changes, only widgets that depend on it are rebuilt.
//!
//! # Implementation
//!
//! Use `#[derive(InheritedWidget)]` from `flui_derive` to automatically generate
//! the `Widget` and `DynWidget` implementations.

use std::fmt;
use super::{BoxedWidget, DynWidget};

/// InheritedWidget - widget that provides data to descendants
///
/// InheritedWidgets are a way to propagate information down the tree efficiently.
/// Descendant widgets can access the InheritedWidget and optionally register a
/// dependency so they rebuild when the data changes.
///
/// # Architecture
///
/// ```text
/// InheritedWidget
///   ↓
/// InheritedElement (stores dependents: HashSet<ElementId>)
///   ↓
/// Child widget tree (can access via context.depend_on::<T>())
/// ```
///
/// # Example
///
/// ```rust,ignore
/// use flui_core::{InheritedWidget, BoxedWidget};
/// use flui_derive::InheritedWidget as DeriveInheritedWidget;
///
/// #[derive(DeriveInheritedWidget, Debug, Clone)]
/// struct Theme {
///     primary_color: Color,
///     text_size: f32,
///     child: BoxedWidget,
/// }
///
/// impl InheritedWidget for Theme {
///     fn update_should_notify(&self, old: &Self) -> bool {
///         self.primary_color != old.primary_color ||
///         self.text_size != old.text_size
///     }
///
///     fn child(&self) -> BoxedWidget {
///         self.child.clone()
///     }
/// }
/// // Widget and DynWidget auto-generated by derive macro!
/// ```
///
/// # Accessing from descendants
///
/// ```rust,ignore
/// // With dependency (auto-rebuild on change)
/// let theme = context.depend_on::<Theme>()?;
///
/// // Without dependency (one-time read)
/// let theme = context.read::<Theme>()?;
/// ```
///
/// # Performance
///
/// - Only widgets that call `depend_on()` are notified of changes
/// - `update_should_notify()` controls when dependents rebuild
/// - Efficient: O(1) lookup up the ancestor chain
///
/// # Derive Macro
///
/// Use `#[derive(InheritedWidget)]` from `flui_derive` to auto-implement
/// `Widget` (with `type Element = InheritedElement<Self>`) and `DynWidget`.
pub trait InheritedWidget: fmt::Debug + Clone + Send + Sync + DynWidget + 'static {
    /// Check if dependents should be notified of changes
    ///
    /// Called when the InheritedWidget is updated with new data.
    /// Return `true` to rebuild all dependent widgets, `false` to skip.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// fn update_should_notify(&self, old: &Self) -> bool {
    ///     // Only notify if color changed, ignore other fields
    ///     self.primary_color != old.primary_color
    /// }
    /// ```
    fn update_should_notify(&self, old: &Self) -> bool;

    /// Get the child widget
    ///
    /// InheritedWidgets always have exactly one child that forms the subtree
    /// where this data is available.
    fn child(&self) -> BoxedWidget;
}
