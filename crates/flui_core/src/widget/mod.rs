//! Widget system - immutable configuration for UI elements
//!
//! Based on idea.md Chapter 4 with extensions for StatelessWidget and StatefulWidget.
//!
//! # Widget Types
//!
//! 1. **StatelessWidget** - Builds once, no mutable state
//! 2. **StatefulWidget** - Creates a State object that persists across rebuilds
//! 3. **InheritedWidget** - Propagates data down the tree efficiently
//! 4. **ParentDataWidget** - Attaches metadata to descendant RenderObjects
//! 5. **RenderObjectWidget** - Directly controls layout and painting
//!
//! # Architecture
//!
//! ```text
//! Widget (immutable config)
//!   ├─ StatelessWidget → ComponentElement → build() → child widget
//!   ├─ StatefulWidget → StatefulElement → State → build() → child widget
//!   ├─ InheritedWidget → InheritedElement → (data propagation) → child widget
//!   ├─ ParentDataWidget → ParentDataElement → (attach data) → child widget
//!   └─ RenderObjectWidget → RenderObjectElement<W, A> → RenderObject (layout/paint)
//! ```
//!
//! # Widget Kind System
//!
//! Widget implementations are generated via derive macros from the `flui_derive` crate.
//! This avoids trait coherence conflicts and provides a standard Rust pattern.
//!
//! # Module Structure
//!
//! - `dyn_widget` - Object-safe DynWidget trait for heterogeneous storage
//! - `stateless` - StatelessWidget trait for immutable widgets
//! - `stateful` - StatefulWidget + State traits for stateful widgets
//! - `inherited` - InheritedWidget trait for data propagation
//! - `proxy` - ProxyWidget trait for single-child wrapper widgets
//! - `parent_data_widget` - ParentDataWidget trait for attaching layout metadata
//! - `render_object_widget` - RenderObjectWidget trait for render widgets

// Submodules
pub mod dyn_widget;
pub mod inherited;
pub mod parent_data_widget;
pub mod proxy;
pub mod render_object_widget;
pub mod stateful;
pub mod stateful_wrapper;
pub mod stateless;






// Re-exports for convenience
pub use dyn_widget::{DynWidget, BoxedWidget};
pub use stateless::StatelessWidget;
pub use stateful::{StatefulWidget, State};
pub use stateful_wrapper::Stateful;  // Zero-cost wrapper for StatefulWidget
pub use inherited::InheritedWidget;
pub use proxy::ProxyWidget;
pub use parent_data_widget::ParentDataWidget;
pub use render_object_widget::RenderObjectWidget;

/// Base Widget trait
///
/// All widgets must be Clone (immutable) and Send + Sync for thread safety.
///
/// # Implementation
///
/// **Don't implement this trait directly!** Instead, use one of:
///
/// 1. **Derive macros** (recommended):
///    ```rust,ignore
///    #[derive(StatelessWidget, Clone, Debug)]
///    struct MyWidget { /* ... */ }
///
///    impl StatelessWidget for MyWidget {
///        fn build(&self) -> BoxedWidget { /* ... */ }
///    }
///    // Widget and DynWidget auto-generated!
///    ```
///
/// 2. **Higher-level widget traits**:
///    - `StatelessWidget` - for widgets without state
///    - `StatefulWidget` - for widgets with mutable state (use `Stateful` wrapper)
///    - `InheritedWidget` - for data propagation
///    - `ParentDataWidget` - for layout metadata
///    - `RenderObjectWidget` - for rendering
///
/// # Example: Using Derives
///
/// ```rust,ignore
/// use flui_core::{StatelessWidget, BoxedWidget};
/// use flui_derive::StatelessWidget as DeriveStatelessWidget;
///
/// #[derive(DeriveStatelessWidget, Clone, Debug)]
/// struct Greeting {
///     name: String,
/// }
///
/// impl StatelessWidget for Greeting {
///     fn build(&self) -> BoxedWidget {
///         Box::new(Text::new(format!("Hello, {}!", self.name)))
///     }
/// }
/// // ✅ Widget + DynWidget automatically generated by macro!
/// ```
pub trait Widget: DynWidget + Clone + Sized {
    /// Element type created by this widget
    ///
    /// Each widget type creates a specific Element type:
    /// - StatelessWidget → ComponentElement
    /// - StatefulWidget (via Stateful) → StatefulElement
    /// - InheritedWidget → InheritedElement
    /// - ParentDataWidget → ParentDataElement
    /// - RenderObjectWidget → RenderObjectElement
    type Element: crate::element::DynElement;

    /// Optional key for widget identity
    ///
    /// Keys are used to preserve element state when the widget tree is rebuilt.
    /// If two widgets have different keys, they are considered different even if
    /// they are the same type.
    fn key(&self) -> Option<&str> {
        None
    }

    /// Create an element from this widget
    ///
    /// This is automatically implemented by derive macros.
    fn into_element(self) -> Self::Element;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::render::{RenderObject, LeafArity, LayoutCx, PaintCx};
    use flui_types::Size;
    use flui_engine::{BoxedLayer, ContainerLayer};

    #[derive(Clone, Debug)]
    struct TestWidget {
        value: f32,
    }

    // Widget and DynWidget are automatically implemented via RenderObjectWidget!

    #[derive(Debug)]
    struct TestRender {
        value: f32,
    }

    impl RenderObject for TestRender {
        type Arity = LeafArity;

        fn layout(&mut self, cx: &mut LayoutCx<Self::Arity>) -> Size {
            cx.constraints().constrain(Size::ZERO)
        }

        fn paint(&self, _cx: &PaintCx<Self::Arity>) -> BoxedLayer {
            Box::new(ContainerLayer::new())
        }
    }

    impl RenderObjectWidget for TestWidget {
        type Arity = LeafArity;
        type Render = TestRender;

        fn create_render_object(&self) -> Self::Render {
            TestRender { value: self.value }
        }

        fn update_render_object(&self, render: &mut Self::Render) {
            render.value = self.value;
        }
    }

    #[test]
    fn test_render_object_widget() {
        let widget = TestWidget { value: 42.0 };
        let mut render = widget.create_render_object();

        assert_eq!(render.value, 42.0);

        let updated_widget = TestWidget { value: 100.0 };
        updated_widget.update_render_object(&mut render);

        assert_eq!(render.value, 100.0);
    }
}





