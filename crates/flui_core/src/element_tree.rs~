//! Element Tree - manages the Widget → Element → RenderObject tree
//!
//! This module provides the ElementTree type that manages the lifecycle of the element tree.
//! It handles mounting, updating, rebuilding, and unmounting elements.
//!
//! # Architecture
//!
//! The ElementTree is the core of Flui's reactive system. It maintains the mapping between
//! widgets and their corresponding elements, manages parent-child relationships, and
//! schedules rebuilds when elements are marked dirty.
//!
//! ```text
//! ElementTree
//! ├── Root Element
//! │   ├── Child Element 1
//! │   │   └── Grandchild Element
//! │   └── Child Element 2
//! └── Dirty elements queue (for rebuilding)
//! ```
//!
//! # Usage
//!
//! ```rust,ignore
//! use flui_core::{ElementTree, Widget};
//!
//! let mut tree = ElementTree::new();
//!
//! // Mount root widget
//! let root_widget = MyApp::new();
//! tree.mount_root(Box::new(root_widget));
//!
//! // Process dirty elements
//! tree.rebuild_dirty_elements();
//! ```

use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use parking_lot::RwLock;

use crate::{Element, ElementId, Widget};

/// ElementTree - manages the element tree lifecycle
///
/// Similar to Flutter's BuildOwner. Manages element lifecycle, tracks dirty elements,
/// and schedules rebuilds.
///
/// # Responsibilities
///
/// 1. **Tree Management**: Maintains parent-child relationships
/// 2. **Lifecycle**: Handles mount, update, unmount operations
/// 3. **Dirty Tracking**: Tracks which elements need rebuild
/// 4. **Rebuild Scheduling**: Processes dirty elements in correct order
///
/// # Example
///
/// ```rust,ignore
/// let mut tree = ElementTree::new();
///
/// // Mount root
/// tree.mount_root(Box::new(MyApp::new()));
///
/// // Mark element dirty (e.g., from setState)
/// tree.mark_element_dirty(element_id);
///
/// // Rebuild all dirty elements
/// tree.rebuild_dirty_elements();
/// ```
#[derive(Debug)]
pub struct ElementTree {
    /// Root element of the tree
    root: Option<ElementId>,

    /// All elements in the tree, indexed by their ID
    elements: HashMap<ElementId, Box<dyn Element>>,

    /// Elements that need to be rebuilt (marked dirty)
    dirty_elements: VecDeque<ElementId>,

    /// Whether we're currently building (prevents recursive builds)
    building: bool,
}

impl ElementTree {
    /// Create a new empty element tree
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let tree = ElementTree::new();
    /// assert!(!tree.has_root());
    /// ```
    pub fn new() -> Self {
        Self {
            root: None,
            elements: HashMap::new(),
            dirty_elements: VecDeque::new(),
            building: false,
        }
    }

    /// Check if the tree has a root element
    ///
    /// # Returns
    ///
    /// `true` if a root element has been mounted, `false` otherwise.
    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    /// Get the root element ID
    ///
    /// # Returns
    ///
    /// The root element ID, or `None` if no root has been mounted.
    pub fn root(&self) -> Option<ElementId> {
        self.root
    }

    /// Get the root RenderObject by traversing from root element
    ///
    /// Walks down the element tree to find the first RenderObject.
    /// This is useful for getting the root of the render tree for layout/paint.
    ///
    /// # Returns
    ///
    /// Reference to the root RenderObject, or None if not found
    ///
    /// # Note
    ///
    /// This is a simplified implementation that only works for simple trees.
    /// In a full implementation, we'd track the render tree separately.
    pub fn root_render_object(&self) -> Option<&dyn crate::RenderObject> {
        let root_id = self.root?;
        self.find_render_object(root_id)
    }

    /// Get mutable reference to root RenderObject
    ///
    /// # Returns
    ///
    /// Mutable reference to the root RenderObject, or None if not found
    pub fn root_render_object_mut(&mut self) -> Option<&mut dyn crate::RenderObject> {
        let root_id = self.root?;
        self.find_render_object_mut(root_id)
    }

    /// Find RenderObject starting from given element ID (immutable)
    fn find_render_object(&self, element_id: ElementId) -> Option<&dyn crate::RenderObject> {
        let element = self.get_element(element_id)?;

        // Check if this element has a RenderObject
        if let Some(render_object) = element.render_object() {
            return Some(render_object);
        }

        // If not, search in children - collect IDs first to avoid borrow issues
        let mut child_ids = Vec::new();
        element.visit_children(&mut |child| {
            child_ids.push(child.id());
        });

        // Search children recursively
        for child_id in child_ids {
            if let Some(render_object) = self.find_render_object(child_id) {
                return Some(render_object);
            }
        }

        None
    }

    /// Find RenderObject starting from given element ID (mutable)
    ///
    /// # Note
    ///
    /// This is complex to implement correctly due to Rust's borrow checker.
    /// For now, we use unsafe to achieve the desired behavior.
    fn find_render_object_mut(&mut self, element_id: ElementId) -> Option<&mut dyn crate::RenderObject> {
        // Check if this element has a RenderObject
        let has_render_object = self.elements.get(&element_id)?.render_object().is_some();

        if has_render_object {
            // Get mutable reference
            return self.elements.get_mut(&element_id)?.render_object_mut();
        }

        // Collect child IDs
        let child_ids: Vec<ElementId> = {
            let element = self.elements.get(&element_id)?;
            let mut ids = Vec::new();
            element.visit_children(&mut |child| {
                ids.push(child.id());
            });
            ids
        };

        // Search children - only search first child for now
        // Full recursive search requires more complex lifetime management
        if let Some(&first_child) = child_ids.first() {
            return self.find_render_object_mut(first_child);
        }

        None
    }

    /// Mount a widget as the root of the tree
    ///
    /// This creates a new element from the widget and mounts it as the root.
    /// If a root already exists, it will be unmounted first.
    ///
    /// # Parameters
    ///
    /// - `widget`: The root widget to mount
    ///
    /// # Returns
    ///
    /// The ElementId of the newly mounted root element
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let mut tree = ElementTree::new();
    /// let root_id = tree.mount_root(Box::new(MyApp::new()));
    /// assert_eq!(tree.root(), Some(root_id));
    /// ```
    pub fn mount_root(&mut self, widget: Box<dyn Widget>) -> ElementId {
        // Unmount existing root if present
        if let Some(old_root_id) = self.root {
            self.unmount_element(old_root_id);
        }

        // Create element from widget
        let mut element = widget.create_element();
        let element_id = element.id();

        // Mount the element (no parent, slot 0)
        element.mount(None, 0);

        // Store in tree
        self.elements.insert(element_id, element);
        self.root = Some(element_id);

        // Mark as dirty for initial build
        self.mark_element_dirty(element_id);

        element_id
    }

    /// Set tree reference for an element
    ///
    /// This is called internally to give ComponentElements access to the tree
    /// so they can mount their children.
    ///
    /// # Parameters
    ///
    /// - `element_id`: ID of the element
    /// - `tree`: Arc reference to the element tree
    pub fn set_element_tree_ref(&mut self, element_id: ElementId, tree: Arc<RwLock<Self>>) {
        if let Some(element) = self.elements.get_mut(&element_id) {
            element.set_tree_ref(tree);
        }
    }

    /// Get an element by ID (immutable)
    ///
    /// # Parameters
    ///
    /// - `id`: The element ID to look up
    ///
    /// # Returns
    ///
    /// Reference to the element, or `None` if not found
    pub fn get_element(&self, id: ElementId) -> Option<&dyn Element> {
        self.elements.get(&id).map(|e| e.as_ref())
    }

    /// Get an element by ID (mutable)
    ///
    /// # Parameters
    ///
    /// - `id`: The element ID to look up
    ///
    /// # Returns
    ///
    /// Mutable reference to the element, or `None` if not found
    pub fn get_element_mut(&mut self, id: ElementId) -> Option<&mut dyn Element> {
        self.elements.get_mut(&id).map(|e| e.as_mut())
    }

    /// Mount a child element under a parent
    ///
    /// Creates an element from the widget and mounts it as a child of the parent.
    ///
    /// # Parameters
    ///
    /// - `parent_id`: Parent element ID
    /// - `widget`: Child widget to mount
    /// - `slot`: Position in parent's child list
    ///
    /// # Returns
    ///
    /// The ElementId of the newly mounted child, or `None` if parent not found
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let child_id = tree.mount_child(parent_id, Box::new(Text::new("Hello")), 0);
    /// ```
    pub fn mount_child(
        &mut self,
        parent_id: ElementId,
        widget: Box<dyn Widget>,
        slot: usize,
    ) -> Option<ElementId> {
        // Verify parent exists
        if !self.elements.contains_key(&parent_id) {
            return None;
        }

        // Create element from widget
        let mut element = widget.create_element();
        let element_id = element.id();

        // Mount the element
        element.mount(Some(parent_id), slot);

        // Store in tree
        self.elements.insert(element_id, element);

        // Mark as dirty for initial build
        self.mark_element_dirty(element_id);

        Some(element_id)
    }

    /// Update an element with a new widget
    ///
    /// If the widget can update the existing element (same type and key), the element
    /// is updated. Otherwise, the old element is unmounted and a new one is created.
    ///
    /// # Parameters
    ///
    /// - `element_id`: The element to update
    /// - `new_widget`: The new widget configuration
    ///
    /// # Returns
    ///
    /// - `Ok(element_id)` if the element was updated in place
    /// - `Ok(new_element_id)` if a new element was created
    /// - `Err(())` if the element was not found
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// // Update with new widget
    /// tree.update_element(element_id, Box::new(Text::new("New text")))?;
    /// ```
    pub fn update_element(
        &mut self,
        element_id: ElementId,
        new_widget: Box<dyn Widget>,
    ) -> Result<ElementId, ()> {
        // Check if element exists
        if !self.elements.contains_key(&element_id) {
            return Err(());
        }

        // Check if we can update in place
        // For now, we'll always try to update (proper widget.can_update check would go here)

        // Remove element temporarily for update
        let mut element = self.elements.remove(&element_id).ok_or(())?;

        // Update the element
        // Note: We're passing the widget as Any - elements handle the downcast
        element.update(Box::new(new_widget));

        // Mark as dirty
        element.mark_dirty();

        // Re-insert
        self.elements.insert(element_id, element);

        // Add to dirty queue
        self.mark_element_dirty(element_id);

        Ok(element_id)
    }

    /// Unmount an element and all its descendants
    ///
    /// Removes the element from the tree and calls unmount() to clean up resources.
    ///
    /// # Parameters
    ///
    /// - `element_id`: The element to unmount
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// tree.unmount_element(element_id);
    /// ```
    pub fn unmount_element(&mut self, element_id: ElementId) {
        // Collect child IDs first (all elements that have this element as parent)
        let child_ids: Vec<ElementId> = self
            .elements
            .iter()
            .filter(|(_, element)| element.parent() == Some(element_id))
            .map(|(id, _)| *id)
            .collect();

        // Unmount children first (recursive)
        for child_id in child_ids {
            self.unmount_element(child_id);
        }

        // Now unmount this element
        if let Some(mut element) = self.elements.remove(&element_id) {
            // Unmount the element
            element.unmount();

            // Remove from dirty queue if present
            self.dirty_elements.retain(|&id| id != element_id);
        }

        // Clear root if this was the root element
        if self.root == Some(element_id) {
            self.root = None;
        }
    }

    /// Mark an element as dirty (needs rebuild)
    ///
    /// Adds the element to the dirty queue for rebuilding. The element will be
    /// rebuilt the next time `rebuild_dirty_elements()` is called.
    ///
    /// # Parameters
    ///
    /// - `element_id`: The element to mark dirty
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// // Mark element dirty (e.g., from setState)
    /// tree.mark_element_dirty(element_id);
    ///
    /// // Later, rebuild all dirty elements
    /// tree.rebuild_dirty_elements();
    /// ```
    pub fn mark_element_dirty(&mut self, element_id: ElementId) {
        // Don't add duplicates
        if !self.dirty_elements.contains(&element_id) {
            self.dirty_elements.push_back(element_id);
        }

        // Mark the element itself as dirty
        if let Some(element) = self.elements.get_mut(&element_id) {
            element.mark_dirty();
        }
    }

    /// Check if there are any dirty elements
    ///
    /// # Returns
    ///
    /// `true` if there are elements that need rebuilding, `false` otherwise
    pub fn has_dirty_elements(&self) -> bool {
        !self.dirty_elements.is_empty()
    }

    /// Get the number of dirty elements
    ///
    /// # Returns
    ///
    /// The number of elements in the dirty queue
    pub fn dirty_element_count(&self) -> usize {
        self.dirty_elements.len()
    }

    /// Rebuild all dirty elements
    ///
    /// Processes the dirty element queue, calling rebuild() on each element.
    /// Elements are rebuilt in the order they were marked dirty.
    ///
    /// This method is idempotent - it's safe to call even if no elements are dirty.
    ///
    /// # Panics
    ///
    /// Panics if called recursively (while already building).
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// // Mark some elements dirty
    /// tree.mark_element_dirty(element1);
    /// tree.mark_element_dirty(element2);
    ///
    /// // Rebuild them all
    /// tree.rebuild_dirty_elements();
    /// ```
    pub fn rebuild_dirty_elements(&mut self) {
        if self.building {
            panic!("ElementTree: Recursive rebuild detected");
        }

        let initial_dirty = self.dirty_elements.len();
        if initial_dirty == 0 {
            tracing::debug!("ElementTree::rebuild_dirty_elements called: no dirty elements");
        } else {
            tracing::info!("ElementTree::rebuild_dirty_elements start: {} dirty elements", initial_dirty);
        }

        self.building = true;

        // Guard against infinite rebuild churn within a single frame
        const MAX_REBUILDS_PER_FRAME: usize = 1024;
        let mut rebuilds_attempted: usize = 0;
        let mut rebuilds_performed: usize = 0;

        // Process dirty queue
        while let Some(element_id) = self.dirty_elements.pop_front() {
            rebuilds_attempted += 1;
            if rebuilds_attempted > MAX_REBUILDS_PER_FRAME {
                // We've likely hit a self-rebuild loop. Keep current and remaining items for the next frame.
                // Push back the current element and any remaining already queued ones.
                self.dirty_elements.push_front(element_id);
                tracing::warn!(
                    "ElementTree: reached MAX_REBUILDS_PER_FRAME ({}). Breaking to avoid infinite build loop. Remaining dirty elements: {}",
                    MAX_REBUILDS_PER_FRAME,
                    self.dirty_elements.len()
                );
                break;
            }

            // Check if element still exists (might have been unmounted)
            if let Some(element) = self.elements.get_mut(&element_id) {
                // Only rebuild if still dirty (might have been cleared)
                if element.is_dirty() {
                    tracing::debug!("ElementTree: rebuilding element {:?}", element_id);
                    element.rebuild();
                    rebuilds_performed += 1;

                    // If it is still dirty after rebuild, re-queue it to try again later.
                    // This allows progress while preventing tight loops in a single frame.
                    if element.is_dirty() {
                        self.dirty_elements.push_back(element_id);
                    }
                }
            }
        }

        self.building = false;

        let remaining = self.dirty_elements.len();
        tracing::debug!(
            "ElementTree::rebuild_dirty_elements end: performed {} rebuild(s), remaining dirty: {}",
            rebuilds_performed,
            remaining
        );
    }

    /// Get the total number of elements in the tree
    ///
    /// # Returns
    ///
    /// The number of mounted elements
    pub fn element_count(&self) -> usize {
        self.elements.len()
    }

    /// Clear the entire tree
    ///
    /// Unmounts all elements and resets the tree to an empty state.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// tree.clear();
    /// assert!(!tree.has_root());
    /// assert_eq!(tree.element_count(), 0);
    /// ```
    pub fn clear(&mut self) {
        if let Some(root_id) = self.root {
            self.unmount_element(root_id);
        }

        self.elements.clear();
        self.dirty_elements.clear();
        self.root = None;
        self.building = false;
    }

    /// Visit all elements in the tree (read-only)
    ///
    /// Traverses the entire tree and calls the visitor function for each element.
    /// The traversal order is depth-first, starting from the root.
    ///
    /// # Parameters
    ///
    /// - `visitor`: Function to call for each element
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// tree.visit_all_elements(&mut |element| {
    ///     println!("Element: {:?}", element.id());
    /// });
    /// ```
    pub fn visit_all_elements<F>(&self, visitor: &mut F)
    where
        F: FnMut(&dyn Element),
    {
        if let Some(root_id) = self.root {
            if let Some(root) = self.elements.get(&root_id) {
                self.visit_element_recursive(root.as_ref(), visitor);
            }
        }
    }

    /// Visit all elements in the tree (mutable)
    ///
    /// Traverses the entire tree and calls the visitor function for each element.
    /// The traversal order is depth-first, starting from the root.
    ///
    /// # Parameters
    ///
    /// - `visitor`: Function to call for each element
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// tree.visit_all_elements_mut(&mut |element| {
    ///     element.mark_dirty();
    /// });
    /// ```
    pub fn visit_all_elements_mut<F>(&mut self, visitor: &mut F)
    where
        F: FnMut(&mut dyn Element),
    {
        if let Some(root_id) = self.root {
            // Collect all element IDs first (can't borrow elements while iterating)
            let mut element_ids = Vec::new();
            element_ids.push(root_id);

            let mut i = 0;
            while i < element_ids.len() {
                let current_id = element_ids[i];
                if let Some(element) = self.elements.get(&current_id) {
                    element.visit_children(&mut |child| {
                        element_ids.push(child.id());
                    });
                }
                i += 1;
            }

            // Now visit all elements
            for element_id in element_ids {
                if let Some(element) = self.elements.get_mut(&element_id) {
                    visitor(element.as_mut());
                }
            }
        }
    }

    /// Helper for recursive element visitation (read-only)
    fn visit_element_recursive<F>(&self, element: &dyn Element, visitor: &mut F)
    where
        F: FnMut(&dyn Element),
    {
        // Visit this element
        visitor(element);

        // Visit children
        element.visit_children(&mut |child| {
            self.visit_element_recursive(child, visitor);
        });
    }
}

impl Default for ElementTree {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{BuildContext, StatelessWidget, Widget};

    // Test widget for testing
    #[derive(Debug, Clone)]
    struct TestWidget {
        name: String,
    }

    impl TestWidget {
        fn new(name: impl Into<String>) -> Self {
            Self { name: name.into() }
        }
    }

    impl StatelessWidget for TestWidget {
        fn build(&self, _context: &BuildContext) -> Box<dyn Widget> {
            Box::new(TestWidget::new(format!("{}_child", self.name)))
        }
    }

    #[test]
    fn test_element_tree_new() {
        let tree = ElementTree::new();
        assert!(!tree.has_root());
        assert_eq!(tree.element_count(), 0);
        assert!(!tree.has_dirty_elements());
    }

    #[test]
    fn test_element_tree_mount_root() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(widget));

        assert!(tree.has_root());
        assert_eq!(tree.root(), Some(root_id));
        assert_eq!(tree.element_count(), 1);
        assert!(tree.has_dirty_elements()); // Newly mounted elements are dirty
    }

    #[test]
    fn test_element_tree_get_element() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(widget));

        // Test get_element
        let element = tree.get_element(root_id).unwrap();
        assert_eq!(element.id(), root_id);

        // Test get_element_mut
        let element_mut = tree.get_element_mut(root_id).unwrap();
        assert_eq!(element_mut.id(), root_id);
    }

    #[test]
    fn test_element_tree_mount_child() {
        let mut tree = ElementTree::new();
        let root_widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(root_widget));

        // Mount a child
        let child_widget = TestWidget::new("child");
        let child_id = tree.mount_child(root_id, Box::new(child_widget), 0);

        assert!(child_id.is_some());
        assert_eq!(tree.element_count(), 2);

        let child = tree.get_element(child_id.unwrap()).unwrap();
        assert_eq!(child.parent(), Some(root_id));
    }

    #[test]
    fn test_element_tree_mount_child_invalid_parent() {
        let mut tree = ElementTree::new();

        let invalid_parent = ElementId(99999);
        let child_widget = TestWidget::new("child");

        let result = tree.mount_child(invalid_parent, Box::new(child_widget), 0);

        assert!(result.is_none());
        assert_eq!(tree.element_count(), 0);
    }

    #[test]
    fn test_element_tree_unmount_element() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(widget));
        assert_eq!(tree.element_count(), 1);

        tree.unmount_element(root_id);

        assert!(!tree.has_root());
        assert_eq!(tree.element_count(), 0);
        assert!(tree.get_element(root_id).is_none());
    }

    #[test]
    fn test_element_tree_unmount_with_children() {
        let mut tree = ElementTree::new();
        let root_widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(root_widget));

        let child1_id = tree.mount_child(root_id, Box::new(TestWidget::new("child1")), 0);
        let child2_id = tree.mount_child(root_id, Box::new(TestWidget::new("child2")), 1);

        assert_eq!(tree.element_count(), 3);

        // Unmount root should unmount all children
        tree.unmount_element(root_id);

        assert_eq!(tree.element_count(), 0);
        assert!(tree.get_element(child1_id.unwrap()).is_none());
        assert!(tree.get_element(child2_id.unwrap()).is_none());
    }

    #[test]
    fn test_element_tree_mark_dirty() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(widget));

        // Clear dirty queue from initial mount
        tree.rebuild_dirty_elements();
        assert!(!tree.has_dirty_elements());

        // Mark dirty
        tree.mark_element_dirty(root_id);

        assert!(tree.has_dirty_elements());
        assert_eq!(tree.dirty_element_count(), 1);

        let element = tree.get_element(root_id).unwrap();
        assert!(element.is_dirty());
    }

    #[test]
    fn test_element_tree_mark_dirty_no_duplicates() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(widget));
        tree.rebuild_dirty_elements();

        // Mark dirty multiple times
        tree.mark_element_dirty(root_id);
        tree.mark_element_dirty(root_id);
        tree.mark_element_dirty(root_id);

        // Should only appear once in queue
        assert_eq!(tree.dirty_element_count(), 1);
    }

    #[test]
    fn test_element_tree_rebuild_dirty_elements() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(widget));
        assert!(tree.has_dirty_elements());

        tree.rebuild_dirty_elements();

        assert!(!tree.has_dirty_elements());
        assert_eq!(tree.dirty_element_count(), 0);

        let element = tree.get_element(root_id).unwrap();
        assert!(!element.is_dirty());
    }

    #[test]
    fn test_element_tree_rebuild_multiple_dirty() {
        let mut tree = ElementTree::new();
        let root_widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(root_widget));
        let child1_id = tree.mount_child(root_id, Box::new(TestWidget::new("child1")), 0).unwrap();
        let child2_id = tree.mount_child(root_id, Box::new(TestWidget::new("child2")), 1).unwrap();

        tree.rebuild_dirty_elements();

        // Mark all dirty
        tree.mark_element_dirty(root_id);
        tree.mark_element_dirty(child1_id);
        tree.mark_element_dirty(child2_id);

        assert_eq!(tree.dirty_element_count(), 3);

        tree.rebuild_dirty_elements();

        assert_eq!(tree.dirty_element_count(), 0);
    }

    #[test]
    #[should_panic(expected = "Recursive rebuild detected")]
    fn test_element_tree_recursive_rebuild_panic() {
        let mut tree = ElementTree::new();
        tree.building = true; // Simulate already building

        tree.rebuild_dirty_elements(); // Should panic
    }

    #[test]
    fn test_element_tree_clear() {
        let mut tree = ElementTree::new();
        let root_widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(root_widget));
        tree.mount_child(root_id, Box::new(TestWidget::new("child")), 0);

        assert_eq!(tree.element_count(), 2);

        tree.clear();

        assert!(!tree.has_root());
        assert_eq!(tree.element_count(), 0);
        assert!(!tree.has_dirty_elements());
    }

    #[test]
    fn test_element_tree_visit_all_elements() {
        let mut tree = ElementTree::new();
        let root_widget = TestWidget::new("root");

        let root_id = tree.mount_root(Box::new(root_widget));
        tree.mount_child(root_id, Box::new(TestWidget::new("child1")), 0);
        tree.mount_child(root_id, Box::new(TestWidget::new("child2")), 1);

        let mut count = 0;
        tree.visit_all_elements(&mut |_element| {
            count += 1;
        });

        // Should visit root only (children aren't actually added to element's children list
        // in our simple test - ComponentElement would need full implementation)
        assert!(count >= 1);
    }

    #[test]
    fn test_element_tree_visit_all_elements_mut() {
        let mut tree = ElementTree::new();
        let root_widget = TestWidget::new("root");

        tree.mount_root(Box::new(root_widget));

        // Mark all elements dirty via visitor
        tree.visit_all_elements_mut(&mut |element| {
            element.mark_dirty();
        });

        // Should have dirty elements
        assert!(tree.has_dirty_elements());
    }

    #[test]
    fn test_element_tree_replace_root() {
        let mut tree = ElementTree::new();
        let widget1 = TestWidget::new("root1");

        let root_id1 = tree.mount_root(Box::new(widget1));
        assert_eq!(tree.root(), Some(root_id1));

        // Mount new root (should replace old one)
        let widget2 = TestWidget::new("root2");
        let root_id2 = tree.mount_root(Box::new(widget2));

        assert_ne!(root_id1, root_id2);
        assert_eq!(tree.root(), Some(root_id2));
        assert_eq!(tree.element_count(), 1);

        // Old root should be gone
        assert!(tree.get_element(root_id1).is_none());
    }

    #[test]
    fn test_element_tree_update_element() {
        let mut tree = ElementTree::new();
        let widget = TestWidget::new("original");

        let element_id = tree.mount_root(Box::new(widget));
        tree.rebuild_dirty_elements();

        // Update with new widget
        let new_widget = TestWidget::new("updated");
        let result = tree.update_element(element_id, Box::new(new_widget));

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), element_id);
        assert!(tree.has_dirty_elements());
    }

    #[test]
    fn test_element_tree_update_invalid_element() {
        let mut tree = ElementTree::new();

        let invalid_id = ElementId(99999);
        let widget = TestWidget::new("test");

        let result = tree.update_element(invalid_id, Box::new(widget));

        assert!(result.is_err());
    }
}
