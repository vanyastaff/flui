# AnimationController Architecture - Complete Summary

## 🎯 Ответ на вопрос

**Да, `AnimationController` строится на паттерне похожем на `ChangeNotifier`!**

В Flutter используются **mixins**:
- `AnimationLocalListenersMixin` - для value listeners
- `AnimationLocalStatusListenersMixin` - для status listeners

Это очень похоже на `ChangeNotifier`, но **разделено на два типа слушателей**:
1. **Value listeners** - срабатывают при изменении значения (0.0 → 0.5 → 1.0)
2. **Status listeners** - срабатывают при изменении статуса (Forward, Reverse, Completed, Dismissed)

---

## 📊 Архитектура AnimationController

```
┌─────────────────────────────────────────────────────────────┐
│                  AnimationController                        │
├─────────────────────────────────────────────────────────────┤
│  Fields:                                                    │
│    - value: f64                   // Current animation value│
│    - status: AnimationStatus      // Forward/Reverse/etc    │
│    - duration: Duration                                     │
│    - ticker: Ticker               // Frame callbacks        │
│                                                             │
│  Listeners (like ChangeNotifier):                          │
│    - value_listeners: ObserverList<VoidCallback>           │
│    - status_listeners: ObserverList<StatusListener>        │
│                                                             │
│  Methods:                                                   │
│    - forward() / reverse()        // Control animation     │
│    - add_listener()               // Subscribe to changes  │
│    - add_status_listener()        // Subscribe to status   │
│    - notify_listeners()           // Notify value changed  │
│    - notify_status_listeners()    // Notify status changed │
│    - dispose()                    // Cleanup               │
└─────────────────────────────────────────────────────────────┘
                        ↓ uses
┌─────────────────────────────────────────────────────────────┐
│                      Ticker                                 │
├─────────────────────────────────────────────────────────────┤
│  - Provides frame callbacks (60fps)                        │
│  - Managed by SchedulerBinding                             │
│  - Created by TickerProvider (vsync)                       │
└─────────────────────────────────────────────────────────────┘
                        ↓ provided by
┌─────────────────────────────────────────────────────────────┐
│            SingleTickerProviderStateMixin                   │
├─────────────────────────────────────────────────────────────┤
│  - Mixin for State classes                                 │
│  - Provides one Ticker per State                           │
│  - Automatically pauses when widget unmounted              │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔄 Сравнение с ChangeNotifier

### BaseController (для других контроллеров)
```rust
pub struct BaseController {
    listeners: ObserverList<VoidCallback>,  // Один тип слушателей
    disposed: bool,
}

impl BaseController {
    pub fn notify_listeners(&self) {
        for listener in &self.listeners {
            listener();
        }
    }
}
```

### AnimationController (расширенная версия)
```rust
pub struct AnimationController {
    // Два типа слушателей!
    value_listeners: ObserverList<VoidCallback>,        // Для значений
    status_listeners: ObserverList<StatusListener>,     // Для статусов
    
    // Дополнительно: ticker для frame callbacks
    ticker: Option<Ticker>,
    
    // Состояние
    value: f64,
    status: AnimationStatus,
    disposed: bool,
}

impl AnimationController {
    // Notify для значений (часто - каждый кадр)
    fn notify_listeners(&self) {
        for listener in &self.value_listeners {
            listener();
        }
    }
    
    // Notify для статуса (редко - при изменении направления)
    fn notify_status_listeners(&self) {
        for listener in &self.status_listeners {
            listener(self.status);
        }
    }
}
```

---

## 🎨 Паттерн использования

### 1. Создание в State

```rust
struct MyAnimatedState {
    controller: Option<AnimationController>,
    ticker_state: SingleTickerProviderState,  // Mixin для ticker
    context: Option<BuildContext>,
}

impl State for MyAnimatedState {
    fn init_state(&mut self) {
        // 1. Создать ticker
        let ticker = self.ticker_state.create_ticker(|elapsed| {
            // Rebuild on every frame
            self.context.mark_dirty();
            TickerFuture::Continue
        });
        
        // 2. Создать controller с vsync
        let mut controller = AnimationController::new(
            &SingleTickerProvider(ticker),
            Duration::from_millis(300)
        );
        
        // 3. Добавить value listener
        controller.add_listener(Box::new(|| {
            println!("Value: {}", controller.value());
        }));
        
        // 4. Добавить status listener
        controller.add_status_listener(Box::new(|status| {
            match status {
                AnimationStatus::Completed => println!("Animation completed!"),
                AnimationStatus::Dismissed => println!("Animation dismissed!"),
                _ => {}
            }
        }));
        
        // 5. Запустить анимацию
        controller.forward(None);
        
        self.controller = Some(controller);
    }
    
    fn build(&mut self, ctx: &BuildContext) -> Box<dyn Widget> {
        let value = self.controller.as_ref().unwrap().value();
        
        // Используем значение анимации
        Opacity::new(value, MyWidget::new()).into_widget()
    }
    
    fn dispose(&mut self) {
        // Важно! Очистить ресурсы
        self.controller.as_mut().unwrap().dispose();
        self.ticker_state.dispose_ticker();
    }
}
```

---

## 🔥 Ключевые отличия от BaseController

| Аспект | BaseController | AnimationController |
|--------|---------------|---------------------|
| **Listeners** | Один тип (value) | Два типа (value + status) |
| **Частота уведомлений** | По требованию | Каждый кадр (60fps) |
| **Ticker** | Нет | Да, для frame callbacks |
| **vsync** | Не нужен | Нужен (TickerProvider) |
| **Lifecycle** | Простой | Сложный (pause/resume) |
| **Использование** | Бизнес-логика | Анимации |

---

## 💡 Почему два типа listeners?

### Value Listeners (часто)
- Срабатывают **каждый кадр** (~60 раз в секунду)
- Используются для перерисовки UI
- Пример: `value = 0.0 → 0.1 → 0.2 → ... → 1.0`

```rust
controller.add_listener(Box::new(|| {
    // Вызывается 60 раз в секунду!
    self.rebuild();
}));
```

### Status Listeners (редко)
- Срабатывают при **изменении направления** (4-5 раз за всю анимацию)
- Используются для бизнес-логики (что делать по завершению)
- Пример: `Dismissed → Forward → Completed`

```rust
controller.add_status_listener(Box::new(|status| {
    // Вызывается только при смене статуса
    match status {
        AnimationStatus::Completed => {
            // Анимация завершена, загрузить следующий экран
            navigator.push(NextScreen::new());
        }
        _ => {}
    }
}));
```

---

## 🎯 Оптимизация: зачем разделение?

**Проблема:** Если использовать один тип listener:
```rust
// Плохо - один тип listener
controller.add_listener(Box::new(|| {
    if controller.status() == AnimationStatus::Completed {
        // Эта проверка выполняется 60 раз в секунду!
        do_expensive_operation();
    }
}));
```

**Решение:** Два типа listeners:
```rust
// Хорошо - value listener только для UI
controller.add_listener(Box::new(|| {
    self.rebuild();  // Легкая операция
}));

// Хорошо - status listener для логики
controller.add_status_listener(Box::new(|status| {
    if status == AnimationStatus::Completed {
        do_expensive_operation();  // Вызывается только 1 раз!
    }
}));
```

---

## 📦 Полный пример с комментариями

```rust
use nebula::prelude::*;

struct FadeInBox;

impl StatefulWidget for FadeInBox {
    type State = FadeInBoxState;
    fn create_state(&self) -> Self::State {
        FadeInBoxState::new()
    }
}

struct FadeInBoxState {
    // AnimationController - как ChangeNotifier, но с двумя типами listeners
    controller: Option<AnimationController>,
    
    // Ticker provider mixin
    ticker_state: SingleTickerProviderState,
    
    context: Option<BuildContext>,
}

impl FadeInBoxState {
    fn new() -> Self {
        Self {
            controller: None,
            ticker_state: SingleTickerProviderState::new(),
            context: None,
        }
    }
}

impl State for FadeInBoxState {
    type Widget = FadeInBox;
    
    fn init_state(&mut self) {
        // Шаг 1: Создать ticker (как часы, тикают каждый кадр)
        let ctx = self.context.clone();
        let ticker = self.ticker_state.create_ticker(move |elapsed| {
            // Этот callback вызывается каждый кадр
            if let Some(context) = &ctx {
                context.mark_dirty();  // Запросить rebuild
            }
            TickerFuture::Continue
        });
        
        // Шаг 2: Создать AnimationController с vsync
        let mut controller = AnimationController::new(
            &SingleTickerProvider(ticker),
            Duration::from_millis(1000),  // 1 секунда
        );
        
        // Шаг 3: VALUE LISTENER - вызывается каждый кадр (60fps)
        let ctx_clone = self.context.clone();
        controller.add_listener(Box::new(move || {
            // Легкая операция - просто rebuild
            println!("Value changed: {}", controller.value());
            if let Some(context) = &ctx_clone {
                context.mark_dirty();
            }
        }));
        
        // Шаг 4: STATUS LISTENER - вызывается редко (при смене статуса)
        controller.add_status_listener(Box::new(|status| {
            // Тяжелая операция - только когда нужно
            match status {
                AnimationStatus::Completed => {
                    println!("✅ Fade in completed!");
                    // Можно запустить следующую анимацию или действие
                }
                AnimationStatus::Dismissed => {
                    println!("❌ Animation dismissed");
                }
                AnimationStatus::Forward => {
                    println!("â–¶ï¸ Animation started forward");
                }
                AnimationStatus::Reverse => {
                    println!("â—€ï¸ Animation started reverse");
                }
            }
        }));
        
        // Шаг 5: Запустить анимацию
        controller.forward(None);
        
        self.controller = Some(controller);
    }
    
    fn build(&mut self, context: &BuildContext) -> Box<dyn Widget> {
        // Получить текущее значение (0.0 → 1.0)
        let opacity = self.controller.as_ref()
            .map(|c| c.value())
            .unwrap_or(0.0);
        
        // Применить к виджету
        Opacity::new(
            opacity,
            Container::new()
                .width(200.0)
                .height(200.0)
                .color(Color::BLUE)
                .child(
                    Center::new(
                        Text::new("Fading In!")
                            .color(Color::WHITE)
                    )
                )
        ).into_widget()
    }
    
    fn dispose(&mut self) {
        // ВАЖНО: Очистить ресурсы!
        if let Some(controller) = &mut self.controller {
            controller.dispose();  // Остановит ticker и очистит listeners
        }
        self.ticker_state.dispose_ticker();
    }
    
    // ... другие методы State ...
}
```

---

## 🎓 Резюме

### AnimationController = Enhanced ChangeNotifier

**Базовый паттерн (тот же):**
```rust
// Оба используют Observer pattern
add_listener() → ObserverList → notify_listeners()
```

**Расширения для анимаций:**
1. ✅ **Два типа listeners** (value + status) для оптимизации
2. ✅ **Ticker integration** для frame callbacks
3. ✅ **TickerProvider** (vsync) для синхронизации с экраном
4. ✅ **Lifecycle management** (pause/resume при unmount)

**Использование:**
- `TextEditingController` - простой, один тип listeners
- `ScrollController` - простой, один тип listeners  
- `AnimationController` - сложный, два типа listeners + ticker

**Вывод:** AnimationController - это ChangeNotifier на стероидах! 💪
