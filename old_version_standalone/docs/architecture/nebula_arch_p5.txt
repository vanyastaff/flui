# Nebula Framework - Complete Architecture Documentation
## Part 5: Controllers, Provider System & Performance Optimization

---

## ðŸŽ® Controller System (Like Flutter)

### Base Controller Trait (`nebula_foundation/controller.rs`)

```rust
use std::sync::{Arc, Mutex, Weak};

/// ChangeNotifier trait - base for all controllers
pub trait ChangeNotifier: Send + Sync {
    /// Add a listener
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId;
    
    /// Remove a listener
    fn remove_listener(&mut self, id: ListenerId);
    
    /// Notify all listeners
    fn notify_listeners(&self);
    
    /// Dispose of this controller
    fn dispose(&mut self);
    
    /// Check if disposed
    fn is_disposed(&self) -> bool;
}

/// Base controller implementation
pub struct BaseController {
    listeners: ObserverList<VoidCallback>,
    disposed: bool,
}

impl BaseController {
    pub fn new() -> Self {
        Self {
            listeners: ObserverList::new(),
            disposed: false,
        }
    }
    
    pub fn assert_not_disposed(&self) {
        assert!(!self.disposed, "Controller was used after being disposed");
    }
}

impl ChangeNotifier for BaseController {
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId {
        self.assert_not_disposed();
        self.listeners.add(listener)
    }
    
    fn remove_listener(&mut self, id: ListenerId) {
        self.listeners.remove(id);
    }
    
    fn notify_listeners(&self) {
        self.assert_not_disposed();
        for listener in self.listeners.iter() {
            listener();
        }
    }
    
    fn dispose(&mut self) {
        assert!(!self.disposed, "Controller disposed twice");
        self.disposed = true;
        self.listeners = ObserverList::new();
    }
    
    fn is_disposed(&self) -> bool {
        self.disposed
    }
}
```

---

### TextEditingController (`nebula_widgets/input/text_editing_controller.rs`)

```rust
/// TextEditingController - manages text input state
pub struct TextEditingController {
    base: BaseController,
    value: TextEditingValue,
}

/// TextEditingValue - the current state of text input
#[derive(Debug, Clone, PartialEq)]
pub struct TextEditingValue {
    pub text: String,
    pub selection: TextSelection,
    pub composing: TextRange,
}

/// TextSelection - cursor and selection state
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TextSelection {
    pub base_offset: usize,
    pub extent_offset: usize,
    pub affinity: TextAffinity,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TextAffinity {
    Upstream,
    Downstream,
}

impl TextSelection {
    pub fn collapsed(offset: usize) -> Self {
        Self {
            base_offset: offset,
            extent_offset: offset,
            affinity: TextAffinity::Downstream,
        }
    }
    
    pub fn is_collapsed(&self) -> bool {
        self.base_offset == self.extent_offset
    }
    
    pub fn start(&self) -> usize {
        self.base_offset.min(self.extent_offset)
    }
    
    pub fn end(&self) -> usize {
        self.base_offset.max(self.extent_offset)
    }
}

impl TextEditingController {
    pub fn new() -> Self {
        Self::with_text("")
    }
    
    pub fn with_text(text: impl Into<String>) -> Self {
        let text = text.into();
        let offset = text.len();
        
        Self {
            base: BaseController::new(),
            value: TextEditingValue {
                text,
                selection: TextSelection::collapsed(offset),
                composing: TextRange::empty(),
            },
        }
    }
    
    /// Get current text
    pub fn text(&self) -> &str {
        &self.value.text
    }
    
    /// Set text and move cursor to end
    pub fn set_text(&mut self, text: impl Into<String>) {
        let text = text.into();
        let offset = text.len();
        
        self.value = TextEditingValue {
            text,
            selection: TextSelection::collapsed(offset),
            composing: TextRange::empty(),
        };
        
        self.base.notify_listeners();
    }
    
    /// Get current value
    pub fn value(&self) -> &TextEditingValue {
        &self.value
    }
    
    /// Set value
    pub fn set_value(&mut self, value: TextEditingValue) {
        if self.value != value {
            self.value = value;
            self.base.notify_listeners();
        }
    }
    
    /// Get selection
    pub fn selection(&self) -> TextSelection {
        self.value.selection
    }
    
    /// Set selection
    pub fn set_selection(&mut self, selection: TextSelection) {
        self.value.selection = selection;
        self.base.notify_listeners();
    }
    
    /// Clear text
    pub fn clear(&mut self) {
        self.set_text("");
    }
}

impl ChangeNotifier for TextEditingController {
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId {
        self.base.add_listener(listener)
    }
    
    fn remove_listener(&mut self, id: ListenerId) {
        self.base.remove_listener(id);
    }
    
    fn notify_listeners(&self) {
        self.base.notify_listeners();
    }
    
    fn dispose(&mut self) {
        self.base.dispose();
    }
    
    fn is_disposed(&self) -> bool {
        self.base.is_disposed()
    }
}

// Usage with TextField
struct MyForm {
    controller: Arc<Mutex<TextEditingController>>,
}

impl State for MyFormState {
    fn init_state(&mut self) {
        // Listen to text changes
        let ctrl = self.controller.clone();
        self.controller.lock().unwrap().add_listener(Box::new(move || {
            let text = ctrl.lock().unwrap().text().to_string();
            println!("Text changed: {}", text);
        }));
    }
    
    fn build(&mut self, ctx: &BuildContext) -> Box<dyn Widget> {
        TextField::new()
            .controller(self.controller.clone())
            .on_submitted(|text| {
                println!("Submitted: {}", text);
            })
            .into_widget()
    }
    
    fn dispose(&mut self) {
        self.controller.lock().unwrap().dispose();
    }
}
```

---

### ScrollController (`nebula_widgets/scrolling/scroll_controller.rs`)

```rust
/// ScrollController - controls scroll position
pub struct ScrollController {
    base: BaseController,
    initial_scroll_offset: f64,
    position: Option<Arc<Mutex<ScrollPosition>>>,
}

/// ScrollPosition - tracks current scroll state
pub struct ScrollPosition {
    pub pixels: f64,
    pub min_scroll_extent: f64,
    pub max_scroll_extent: f64,
    pub viewport_dimension: f64,
    pub axis_direction: AxisDirection,
}

impl ScrollController {
    pub fn new() -> Self {
        Self::with_initial_offset(0.0)
    }
    
    pub fn with_initial_offset(offset: f64) -> Self {
        Self {
            base: BaseController::new(),
            initial_scroll_offset: offset,
            position: None,
        }
    }
    
    /// Get current scroll offset
    pub fn offset(&self) -> f64 {
        self.position.as_ref()
            .map(|p| p.lock().unwrap().pixels)
            .unwrap_or(self.initial_scroll_offset)
    }
    
    /// Jump to specific offset (no animation)
    pub fn jump_to(&mut self, offset: f64) {
        if let Some(pos) = &self.position {
            let mut pos = pos.lock().unwrap();
            pos.pixels = offset.clamp(pos.min_scroll_extent, pos.max_scroll_extent);
            self.base.notify_listeners();
        }
    }
    
    /// Animate to specific offset
    pub fn animate_to(
        &mut self,
        offset: f64,
        duration: Duration,
        curve: Box<dyn Curve>,
    ) {
        // Create animation and animate scroll position
        unimplemented!("animate_to")
    }
    
    /// Check if at the top
    pub fn at_edge_top(&self) -> bool {
        self.position.as_ref()
            .map(|p| {
                let pos = p.lock().unwrap();
                pos.pixels <= pos.min_scroll_extent
            })
            .unwrap_or(false)
    }
    
    /// Check if at the bottom
    pub fn at_edge_bottom(&self) -> bool {
        self.position.as_ref()
            .map(|p| {
                let pos = p.lock().unwrap();
                pos.pixels >= pos.max_scroll_extent
            })
            .unwrap_or(false)
    }
    
    /// Attach to scroll position
    pub(crate) fn attach(&mut self, position: Arc<Mutex<ScrollPosition>>) {
        self.position = Some(position);
    }
    
    /// Detach from scroll position
    pub(crate) fn detach(&mut self) {
        self.position = None;
    }
}

impl ChangeNotifier for ScrollController {
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId {
        self.base.add_listener(listener)
    }
    
    fn remove_listener(&mut self, id: ListenerId) {
        self.base.remove_listener(id);
    }
    
    fn notify_listeners(&self) {
        self.base.notify_listeners();
    }
    
    fn dispose(&mut self) {
        self.base.dispose();
        self.position = None;
    }
    
    fn is_disposed(&self) -> bool {
        self.base.is_disposed()
    }
}

// Usage
struct ScrollableList {
    controller: Arc<Mutex<ScrollController>>,
}

impl State for ScrollableListState {
    fn init_state(&mut self) {
        // Listen to scroll changes
        let ctrl = self.controller.clone();
        self.controller.lock().unwrap().add_listener(Box::new(move || {
            let offset = ctrl.lock().unwrap().offset();
            println!("Scrolled to: {}", offset);
        }));
    }
    
    fn build(&mut self, ctx: &BuildContext) -> Box<dyn Widget> {
        Column::new()
            .children(vec![
                // Scroll to top button
                Button::new("Scroll to Top")
                    .on_pressed(|| {
                        self.controller.lock().unwrap().jump_to(0.0);
                    })
                    .into_widget(),
                
                // Scrollable content
                ListView::new()
                    .controller(self.controller.clone())
                    .children(/* ... */)
                    .into_widget(),
            ])
            .into_widget()
    }
}
```

---

### PageController (`nebula_widgets/scrolling/page_controller.rs`)

```rust
/// PageController - controls PageView
pub struct PageController {
    base: BaseController,
    initial_page: usize,
    viewport_fraction: f64,
    current_page: f64,
}

impl PageController {
    pub fn new() -> Self {
        Self {
            base: BaseController::new(),
            initial_page: 0,
            viewport_fraction: 1.0,
            current_page: 0.0,
        }
    }
    
    pub fn with_initial_page(page: usize) -> Self {
        Self {
            base: BaseController::new(),
            initial_page: page,
            viewport_fraction: 1.0,
            current_page: page as f64,
        }
    }
    
    /// Get current page (can be fractional during animation)
    pub fn page(&self) -> f64 {
        self.current_page
    }
    
    /// Jump to page
    pub fn jump_to_page(&mut self, page: usize) {
        self.current_page = page as f64;
        self.base.notify_listeners();
    }
    
    /// Animate to page
    pub fn animate_to_page(
        &mut self,
        page: usize,
        duration: Duration,
        curve: Box<dyn Curve>,
    ) {
        // Animate current_page from current to target
        unimplemented!()
    }
    
    /// Go to next page
    pub fn next_page(&mut self, duration: Duration, curve: Box<dyn Curve>) {
        let next = (self.current_page as usize) + 1;
        self.animate_to_page(next, duration, curve);
    }
    
    /// Go to previous page
    pub fn previous_page(&mut self, duration: Duration, curve: Box<dyn Curve>) {
        let prev = (self.current_page as usize).saturating_sub(1);
        self.animate_to_page(prev, duration, curve);
    }
}
```

---

### TabController (`nebula_widgets/tabs/tab_controller.rs`)

```rust
/// TabController - manages tab selection
pub struct TabController {
    base: BaseController,
    index: usize,
    length: usize,
    animation: Option<Arc<Mutex<AnimationController>>>,
}

impl TabController {
    pub fn new(length: usize) -> Self {
        Self {
            base: BaseController::new(),
            index: 0,
            length,
            animation: None,
        }
    }
    
    pub fn with_initial_index(length: usize, index: usize) -> Self {
        assert!(index < length, "Index out of bounds");
        Self {
            base: BaseController::new(),
            index,
            length,
            animation: None,
        }
    }
    
    /// Get current index
    pub fn index(&self) -> usize {
        self.index
    }
    
    /// Get tab count
    pub fn length(&self) -> usize {
        self.length
    }
    
    /// Set index
    pub fn set_index(&mut self, index: usize) {
        assert!(index < self.length, "Index out of bounds");
        if self.index != index {
            self.index = index;
            self.base.notify_listeners();
        }
    }
    
    /// Animate to index
    pub fn animate_to(&mut self, index: usize) {
        assert!(index < self.length, "Index out of bounds");
        // Animate tab indicator
        unimplemented!()
    }
}

impl ChangeNotifier for TabController {
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId {
        self.base.add_listener(listener)
    }
    
    fn remove_listener(&mut self, id: ListenerId) {
        self.base.remove_listener(id);
    }
    
    fn notify_listeners(&self) {
        self.base.notify_listeners();
    }
    
    fn dispose(&mut self) {
        self.base.dispose();
        if let Some(anim) = &self.animation {
            anim.lock().unwrap().dispose();
        }
    }
    
    fn is_disposed(&self) -> bool {
        self.base.is_disposed()
    }
}
```

---

## ðŸ“¦ Provider System (State Management)

### Provider Core (`crates/nebula_provider/src/lib.rs`)

```rust
use nebula_core::*;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

/// Provider - provides data down the widget tree
pub struct Provider<T: Clone + Send + Sync + 'static> {
    data: T,
    child: Box<dyn Widget>,
}

impl<T: Clone + Send + Sync + 'static> Provider<T> {
    pub fn new(data: T, child: impl IntoWidget) -> Self {
        Self {
            data,
            child: child.into_widget(),
        }
    }
}

impl<T: Clone + Send + Sync + 'static> Widget for Provider<T> {
    fn create_element(&self) -> Box<dyn Element> {
        Box::new(ProviderElement::new(self.clone()))
    }
}

impl<T: Clone + Send + Sync + 'static> InheritedWidget for Provider<T> {
    fn update_should_notify(&self, old: &Self) -> bool {
        // Use PartialEq if T implements it
        false // Default: don't notify (user can override)
    }
    
    fn data(&self) -> &dyn Any {
        &self.data
    }
}

/// BuildContext extension for Provider
pub trait ProviderExt {
    /// Read value from provider (doesn't listen)
    fn read<T: Clone + Send + Sync + 'static>(&self) -> Option<T>;
    
    /// Watch provider (rebuilds on change)
    fn watch<T: Clone + Send + Sync + 'static>(&self) -> Option<T>;
    
    /// Select specific data from provider
    fn select<T, R, F>(&self, selector: F) -> Option<R>
    where
        T: Clone + Send + Sync + 'static,
        R: Clone + PartialEq,
        F: Fn(&T) -> R;
}

impl ProviderExt for BuildContext {
    fn read<T: Clone + Send + Sync + 'static>(&self) -> Option<T> {
        // Find provider without registering dependency
        self.find_ancestor_widget::<Provider<T>>()
            .map(|provider| provider.data.clone())
    }
    
    fn watch<T: Clone + Send + Sync + 'static>(&self) -> Option<T> {
        // Register dependency and rebuild on change
        self.depend_on_inherited::<Provider<T>>()
            .map(|provider| provider.data.clone())
    }
    
    fn select<T, R, F>(&self, selector: F) -> Option<R>
    where
        T: Clone + Send + Sync + 'static,
        R: Clone + PartialEq,
        F: Fn(&T) -> R,
    {
        self.watch::<T>().map(|data| selector(&data))
    }
}
```

---

### ChangeNotifierProvider

```rust
/// ChangeNotifierProvider - provides a ChangeNotifier
pub struct ChangeNotifierProvider<T: ChangeNotifier + Clone + Send + Sync + 'static> {
    notifier: Arc<Mutex<T>>,
    child: Box<dyn Widget>,
}

impl<T: ChangeNotifier + Clone + Send + Sync + 'static> ChangeNotifierProvider<T> {
    pub fn new(notifier: T, child: impl IntoWidget) -> Self {
        Self {
            notifier: Arc::new(Mutex::new(notifier)),
            child: child.into_widget(),
        }
    }
    
    pub fn create(
        create: impl FnOnce() -> T,
        child: impl IntoWidget,
    ) -> Self {
        Self::new(create(), child)
    }
}

impl<T: ChangeNotifier + Clone + Send + Sync + 'static> Widget for ChangeNotifierProvider<T> {
    fn create_element(&self) -> Box<dyn Element> {
        Box::new(ChangeNotifierProviderElement::new(self.clone()))
    }
}

/// Consumer - rebuilds when ChangeNotifier changes
pub struct Consumer<T: ChangeNotifier + Clone + Send + Sync + 'static> {
    builder: Arc<dyn Fn(&BuildContext, &T) -> Box<dyn Widget> + Send + Sync>,
    _phantom: PhantomData<T>,
}

impl<T: ChangeNotifier + Clone + Send + Sync + 'static> Consumer<T> {
    pub fn new<F>(builder: F) -> Self 
    where
        F: Fn(&BuildContext, &T) -> Box<dyn Widget> + Send + Sync + 'static,
    {
        Self {
            builder: Arc::new(builder),
            _phantom: PhantomData,
        }
    }
}

impl<T: ChangeNotifier + Clone + Send + Sync + 'static> StatefulWidget for Consumer<T> {
    type State = ConsumerState<T>;
    
    fn create_state(&self) -> Self::State {
        ConsumerState {
            listener_id: None,
            notifier: None,
            context: None,
            builder: self.builder.clone(),
        }
    }
}

struct ConsumerState<T: ChangeNotifier + Clone + Send + Sync + 'static> {
    listener_id: Option<ListenerId>,
    notifier: Option<Arc<Mutex<T>>>,
    context: Option<BuildContext>,
    builder: Arc<dyn Fn(&BuildContext, &T) -> Box<dyn Widget> + Send + Sync>,
}

impl<T: ChangeNotifier + Clone + Send + Sync + 'static> State for ConsumerState<T> {
    type Widget = Consumer<T>;
    
    fn init_state(&mut self) {
        // Find provider and listen
        let notifier = self.context().read::<Arc<Mutex<T>>>().unwrap();
        
        let ctx = self.context.clone();
        let id = notifier.lock().unwrap().add_listener(Box::new(move || {
            if let Some(context) = &ctx {
                context.mark_dirty();
            }
        }));
        
        self.listener_id = Some(id);
        self.notifier = Some(notifier);
    }
    
    fn build(&mut self, context: &BuildContext) -> Box<dyn Widget> {
        let notifier = self.notifier.as_ref().unwrap();
        let data = notifier.lock().unwrap();
        (self.builder)(context, &*data)
    }
    
    fn dispose(&mut self) {
        if let (Some(notifier), Some(id)) = (&self.notifier, self.listener_id) {
            notifier.lock().unwrap().remove_listener(id);
        }
    }
    
    fn mark_needs_build(&mut self) {
        if let Some(ctx) = &self.context {
            ctx.mark_dirty();
        }
    }
    
    fn context(&self) -> &BuildContext {
        self.context.as_ref().unwrap()
    }
    
    fn set_context(&mut self, context: BuildContext) {
        self.context = Some(context);
    }
}
```

---

### MultiProvider

```rust
/// MultiProvider - combine multiple providers
pub struct MultiProvider {
    providers: Vec<Box<dyn Fn(Box<dyn Widget>) -> Box<dyn Widget>>>,
    child: Box<dyn Widget>,
}

impl MultiProvider {
    pub fn new(child: impl IntoWidget) -> Self {
        Self {
            providers: Vec::new(),
            child: child.into_widget(),
        }
    }
    
    pub fn add<T: Clone + Send + Sync + 'static>(
        mut self,
        data: T,
    ) -> Self {
        self.providers.push(Box::new(move |child| {
            Provider::new(data.clone(), child).into_widget()
        }));
        self
    }
    
    pub fn add_notifier<T: ChangeNotifier + Clone + Send + Sync + 'static>(
        mut self,
        notifier: T,
    ) -> Self {
        self.providers.push(Box::new(move |child| {
            ChangeNotifierProvider::new(notifier.clone(), child).into_widget()
        }));
        self
    }
}

impl StatelessWidget for MultiProvider {
    fn build(&self, _context: &BuildContext) -> Box<dyn Widget> {
        // Nest providers
        let mut child = self.child.clone();
        for provider in self.providers.iter().rev() {
            child = provider(child);
        }
        child
    }
}

// Usage
fn app() -> Box<dyn Widget> {
    MultiProvider::new(MyApp::new())
        .add(Theme::dark())
        .add(AppConfig::default())
        .add_notifier(CounterModel::new())
        .into_widget()
}
```

---

### Selector (Performance Optimization)

```rust
/// Selector - only rebuild when selected data changes
pub struct Selector<T, R, F>
where
    T: Clone + Send + Sync + 'static,
    R: Clone + PartialEq + Send + Sync + 'static,
    F: Fn(&T) -> R + Send + Sync + 'static,
{
    selector: Arc<F>,
    builder: Arc<dyn Fn(&BuildContext, R) -> Box<dyn Widget> + Send + Sync>,
    _phantom: PhantomData<(T, R)>,
}

impl<T, R, F> Selector<T, R, F>
where
    T: Clone + Send + Sync + 'static,
    R: Clone + PartialEq + Send + Sync + 'static,
    F: Fn(&T) -> R + Send + Sync + 'static,
{
    pub fn new<B>(selector: F, builder: B) -> Self 
    where
        B: Fn(&BuildContext, R) -> Box<dyn Widget> + Send + Sync + 'static,
    {
        Self {
            selector: Arc::new(selector),
            builder: Arc::new(builder),
            _phantom: PhantomData,
        }
    }
}

impl<T, R, F> StatefulWidget for Selector<T, R, F>
where
    T: Clone + Send + Sync + 'static,
    R: Clone + PartialEq + Send + Sync + 'static,
    F: Fn(&T) -> R + Send + Sync + 'static,
{
    type State = SelectorState<T, R, F>;
    
    fn create_state(&self) -> Self::State {
        SelectorState {
            previous_value: None,
            selector: self.selector.clone(),
            builder: self.builder.clone(),
            context: None,
        }
    }
}

struct SelectorState<T, R, F>
where
    T: Clone + Send + Sync + 'static,
    R: Clone + PartialEq + Send + Sync + 'static,
    F: Fn(&T) -> R + Send + Sync + 'static,
{
    previous_value: Option<R>,
    selector: Arc<F>,
    builder: Arc<dyn Fn(&BuildContext, R) -> Box<dyn Widget> + Send + Sync>,
    context: Option<BuildContext>,
}

impl<T, R, F> State for SelectorState<T, R, F>
where
    T: Clone + Send + Sync + 'static,
    R: Clone + PartialEq + Send + Sync + 'static,
    F: Fn(&T) -> R + Send + Sync + 'static,
{
    type Widget = Selector<T, R, F>;
    
    fn build(&mut self, context: &BuildContext) -> Box<dyn Widget> {
        let data = context.watch::<T>().unwrap();
        let value = (self.selector)(&data);
        
        // Only rebuild if selected value changed
        if let Some(prev) = &self.previous_value {
            if prev == &value {
                // No change, skip rebuild
                return Container::new().into_widget();
            }
        }
        
        self.previous_value = Some(value.clone());
        (self.builder)(context, value)
    }
    
    fn mark_needs_build(&mut self) {
        if let Some(ctx) = &self.context {
            ctx.mark_dirty();
        }
    }
    
    fn context(&self) -> &BuildContext {
        self.context.as_ref().unwrap()
    }
    
    fn set_context(&mut self, context: BuildContext) {
        self.context = Some(context);
    }
}

// Usage - only rebuild when count changes, not entire state
Selector::new(
    |state: &AppState| state.count,
    |ctx, count| {
        Text::new(format!("Count: {}", count)).into_widget()
    }
)
```

---

## âš¡ Performance Optimization - Paint Caching

### RepaintBoundary (`nebula_rendering/repaint_boundary.rs`)

```rust
use egui::TextureHandle;

/// RepaintBoundary - caches rendering to avoid repainting
pub struct RepaintBoundary {
    child: Box<dyn Widget>,
}

impl RepaintBoundary {
    pub fn new(child: impl IntoWidget) -> Self {
        Self {
            child: child.into_widget(),
        }
    }
}

impl Widget for RepaintBoundary {
    fn create_element(&self) -> Box<dyn Element> {
        Box::new(RepaintBoundaryElement::new(self.clone()))
    }
}

/// RenderRepaintBoundary - caches paint output
pub struct RenderRepaintBoundary {
    child: Option<Box<dyn RenderObject>>,
    size: Size,
    
    // Cache
    cache: Option<PaintCache>,
    needs_repaint: bool,
}

struct PaintCache {
    texture: TextureHandle,
    size: Size,
    generation: u64,
}

impl RenderRepaintBoundary {
    pub fn new() -> Self {
        Self {
            child: None,
            size: Size::ZERO,
            cache: None,
            needs_repaint: true,
        }
    }
    
    pub fn mark_needs_repaint(&mut self) {
        self.needs_repaint = true;
        self.cache = None;
    }
}

impl RenderObject for RenderRepaintBoundary {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        if let Some(child) = &mut self.child {
            self.size = child.layout(constraints);
        } else {
            self.size = constraints.constrain(Size::ZERO);
        }
        
        // Invalidate cache if size changed
        if let Some(cache) = &self.cache {
            if cache.size != self.size {
                self.cache = None;
                self.needs_repaint = true;
            }
        }
        
        self.size
    }
    
    fn paint(&self, painter: &egui::Painter, offset: Offset) {
        // Check if we have valid cache
        if let Some(cache) = &self.cache {
            if !self.needs_repaint {
                // Use cached texture
                let rect = egui::Rect::from_min_size(
                    egui::pos2(offset.x, offset.y),
                    egui::vec2(cache.size.width, cache.size.height),
                );
                
                painter.image(
                    cache.texture.id(),
                    rect,
                    egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(1.0, 1.0)),
                    egui::Color32::WHITE,
                );
                return;
            }
        }
        
        // Need to repaint - paint to offscreen buffer
        if let Some(child) = &self.child {
            // Create offscreen painter
            let mut offscreen = OffscreenPainter::new(self.size);
            child.paint(&offscreen.painter(), Offset::ZERO);
            
            // Upload to GPU as texture
            let texture = offscreen.to_texture(painter.ctx());
            
            // Cache it
            let cache = PaintCache {
                texture: texture.clone(),
                size: self.size,
                generation: 0,
            };
            
            // Paint cached version
            let rect = egui::Rect::from_min_size(
                egui::pos2(offset.x, offset.y),
                egui::vec2(self.size.width, self.size.height),
            );
            
            painter.image(
                texture.id(),
                rect,
                egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(1.0, 1.0)),
                egui::Color32::WHITE,
            );
            
            // Store cache (using unsafe to modify in immutable method)
            // In real implementation, use RefCell or Mutex
        }
    }
    
    fn size(&self) -> Size {
        self.size
    }
}

/// OffscreenPainter - renders to texture
struct OffscreenPainter {
    size: Size,
    shapes: Vec<egui::Shape>,
}

impl OffscreenPainter {
    fn new(size: Size) -> Self {
        Self {
            size,
            shapes: Vec::new(),
        }
    }
    
    fn painter(&mut self) -> egui::Painter {
        // Create painter that records shapes
        unimplemented!()
    }
    
    fn to_texture(&self, ctx: &egui::Context) -> TextureHandle {
        // Rasterize shapes to texture
        let image = self.rasterize();
        ctx.load_texture(
            "repaint_boundary",
            image,
            egui::TextureOptions::default(),
        )
    }
    
    fn rasterize(&self) -> egui::ColorImage {
        // Convert shapes to pixel buffer
        unimplemented!()
    }
}
```

---

### Automatic Repaint Boundary Detection

```rust
/// Automatically insert RepaintBoundary for expensive widgets
pub struct AutoRepaintBoundary {
    threshold: Duration,
    child: Box<dyn Widget>,
}

impl AutoRepaintBoundary {
    pub fn new(child: impl IntoWidget) -> Self {
        Self {
            threshold: Duration::from_millis(16), // 60fps
            child: child.into_widget(),
        }
    }
}

// In RenderObject
pub trait RenderObject {
    /// Estimate paint cost
    fn estimated_paint_cost(&self) -> Duration {
        Duration::from_micros(100) // Default: cheap
    }
    
    /// Should this be wrapped in RepaintBoundary?
    fn should_use_repaint_boundary(&self) -> bool {
        self.estimated_paint_cost() > Duration::from_millis(16)
    }
}

// Heavy widgets automatically use RepaintBoundary
impl RenderObject for RenderComplexChart {
    fn estimated_paint_cost(&self) -> Duration {
        Duration::from_millis(50) // Expensive!
    }
}
```

---

### Layer Tree Optimization

```rust
/// Layer - composited layer for efficient repainting
pub trait Layer: Any + Debug {
    /// Paint this layer
    fn paint(&self, painter: &egui::Painter, offset: Offset);
    
    /// Add child layer
    fn add_child(&mut self, child: Box<dyn Layer>);
    
    /// Mark needs repaint
    fn mark_needs_paint(&mut self);
}

/// ContainerLayer - can have children
pub struct ContainerLayer {
    children: Vec<Box<dyn Layer>>,
    needs_paint: bool,
}

/// OffsetLayer - translates children
pub struct OffsetLayer {
    offset: Offset,
    child: Option<Box<dyn Layer>>,
}

/// OpacityLayer - applies opacity
pub struct OpacityLayer {
    alpha: u8,
    child: Option<Box<dyn Layer>>,
}

/// TransformLayer - applies transform
pub struct TransformLayer {
    transform: Transform,
    child: Option<Box<dyn Layer>>,
}

// Widgets create layers
impl RenderObject for RenderOpacity {
    fn paint_with_layers(&self) -> Box<dyn Layer> {
        let mut layer = OpacityLayer {
            alpha: (self.opacity * 255.0) as u8,
            child: None,
        };
        
        if let Some(child) = &self.child {
            layer.child = Some(child.paint_with_layers());
        }
        
        Box::new(layer)
    }
}
```

---

## ðŸ“Š Complete Example - Todo App with Provider

```rust
use nebula::prelude::*;
use nebula_provider::*;

fn main() {
    NebulaApp::new(
        ChangeNotifierProvider::create(
            || TodoModel::new(),
            TodoApp::new(),
        )
    )
    .title("Todo App")
    .run()
    .unwrap();
}

// Model
#[derive(Clone)]
struct TodoModel {
    base: BaseController,
    todos: Vec<Todo>,
}

#[derive(Clone, Debug)]
struct Todo {
    id: usize,
    title: String,
    completed: bool,
}

impl TodoModel {
    fn new() -> Self {
        Self {
            base: BaseController::new(),
            todos: Vec::new(),
        }
    }
    
    fn add_todo(&mut self, title: String) {
        let id = self.todos.len();
        self.todos.push(Todo {
            id,
            title,
            completed: false,
        });
        self.base.notify_listeners();
    }
    
    fn toggle_todo(&mut self, id: usize) {
        if let Some(todo) = self.todos.iter_mut().find(|t| t.id == id) {
            todo.completed = !todo.completed;
            self.base.notify_listeners();
        }
    }
    
    fn delete_todo(&mut self, id: usize) {
        self.todos.retain(|t| t.id != id);
        self.base.notify_listeners();
    }
}

impl ChangeNotifier for TodoModel {
    // Implement ChangeNotifier...
}

// UI
struct TodoApp;

impl StatefulWidget for TodoApp {
    type State = TodoAppState;
    fn create_state(&self) -> Self::State {
        TodoAppState {
            text_controller: Arc::new(Mutex::new(TextEditingController::new())),
            context: None,
        }
    }
}

struct TodoAppState {
    text_controller: Arc<Mutex<TextEditingController>>,
    context: Option<BuildContext>,
}

impl State for TodoAppState {
    type Widget = TodoApp;
    
    fn build(&mut self, ctx: &BuildContext) -> Box<dyn Widget> {
        Column::new()
            .children(vec![
                // Input field
                Row::new()
                    .children(vec![
                        Expanded::new(
                            TextField::new()
                                .controller(self.text_controller.clone())
                                .hint("Add a todo...")
                        ).into_widget(),
                        
                        Button::new("Add")
                            .on_pressed(|| {
                                let text = self.text_controller.lock().unwrap()
                                    .text().to_string();
                                
                                if !text.is_empty() {
                                    let mut model = ctx.read::<Arc<Mutex<TodoModel>>>()
                                        .unwrap();
                                    model.lock().unwrap().add_todo(text);
                                    self.text_controller.lock().unwrap().clear();
                                }
                            })
                            .into_widget(),
                    ])
                    .into_widget(),
                
                // Todo list - only rebuild when todos change
                Selector::new(
                    |model: &Arc<Mutex<TodoModel>>| {
                        model.lock().unwrap().todos.clone()
                    },
                    |ctx, todos| {
                        ListView::builder()
                            .item_count(todos.len())
                            .item_builder(move |ctx, index| {
                                TodoItem::new(todos[index].clone()).into_widget()
                            })
                            .into_widget()
                    },
                ).into_widget(),
            ])
            .into_widget()
    }
    
    // ... other State methods
}

// Todo item widget
struct TodoItem {
    todo: Todo,
}

impl StatelessWidget for TodoItem {
    fn build(&self, ctx: &BuildContext) -> Box<dyn Widget> {
        GestureDetector::new(
            RepaintBoundary::new( // Cache rendering
                Container::new()
                    .padding(EdgeInsets::all(8.0))
                    .child(
                        Row::new()
                            .children(vec![
                                Checkbox::new(self.todo.completed)
                                    .on_changed(|_| {
                                        let model = ctx.read::<Arc<Mutex<TodoModel>>>()
                                            .unwrap();
                                        model.lock().unwrap()
                                            .toggle_todo(self.todo.id);
                                    })
                                    .into_widget(),
                                
                                Expanded::new(
                                    Text::new(&self.todo.title)
                                        .strike_through(self.todo.completed)
                                ).into_widget(),
                                
                                IconButton::new(Icon::Delete)
                                    .on_pressed(|| {
                                        let model = ctx.read::<Arc<Mutex<TodoModel>>>()
                                            .unwrap();
                                        model.lock().unwrap()
                                            .delete_todo(self.todo.id);
                                    })
                                    .into_widget(),
                            ])
                    )
            )
        ).into_widget()
    }
}
```

---

## ðŸŽ¯ Key Benefits

### Controllers
âœ… Centralized state management  
âœ… Lifecycle management (dispose)  
âœ… Observable pattern  
âœ… Testable

### Provider
âœ… Dependency injection  
âœ… Automatic rebuilds  
âœ… Selector for fine-grained updates  
âœ… Multiple providers support

### Paint Caching
âœ… RepaintBoundary reduces repaints  
âœ… Layer composition  
âœ… Automatic boundary detection  
âœ… GPU-accelerated caching

**Next:** Part 6 - Testing, Debugging & DevTools
