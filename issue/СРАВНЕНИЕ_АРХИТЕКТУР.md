# Сравнение Архитектурных Подходов

## Текущая Архитектура (ПРОБЛЕМА)

```
┌─────────────────────────────┐
│ MultiChildRenderObjectElement│
├─────────────────────────────┤
│ children: Vec<ElementId>    │ ✅ Знает детей
│ render_object: RenderFlex   │
└─────────────┬───────────────┘
              │
              │ owns
              ▼
┌─────────────────────────────┐
│        RenderFlex           │
├─────────────────────────────┤
│ children: Vec<FlexChild>    │ ❌ ПУСТО!
│ direction: Axis             │
│ size: Size                  │
└─────────────────────────────┘

ПРОБЛЕМА: Element знает детей, но RenderObject нет!
```

## Решение 1: Копирование (НЕ РАБОТАЕТ)

```
MultiChildRenderObjectElement
    ↓ пытаемся копировать
    ├─ get child ElementId
    ├─ get child Element from tree
    ├─ get child RenderObject
    └─ ❌ clone Box<dyn DynRenderObject> 
       НЕВОЗМОЖНО!
```

## Решение 2: RenderContext (ПРАВИЛЬНО)

```
┌──────────────────────────────────────┐
│          PipelineOwner               │
│                                      │
│  fn layout_element(id) {             │
│    // 1. Layout детей (bottom-up)    │
│    for child_id in children {        │
│      layout_element(child_id);       │
│    }                                 │
│                                      │
│    // 2. Layout parent с context     │
│    let ctx = RenderContext {         │
│      tree: &tree,                    │
│      element_id: id,                 │
│    };                                │
│    render_object.layout(ctx);        │
│  }                                   │
└──────────┬───────────────────────────┘
           │
           │ calls with context
           ▼
┌──────────────────────────────────────┐
│         RenderFlex                   │
│                                      │
│  fn layout(constraints, ctx) {       │
│    // Доступ к детям через ctx!      │
│    let element = ctx.tree            │
│                    .get(ctx.id);     │
│                                      │
│    for child_id in element.children()│
│      let child = ctx.tree            │
│                    .get(child_id);   │
│      let size = child.render_object()│
│                      .size();        │ ✅
│      // Используем size для layout   │
│    }                                 │
│  }                                   │
└──────────────────────────────────────┘
```

## Поток Данных

### До (не работает):

```
Widget Tree
    ↓ create
Element Tree (знает детей)
    ↓ create
RenderObject Tree ❌ (не знает детей)
```

### После (работает):

```
Widget Tree
    ↓ create
Element Tree (знает детей)
    ↓ create & pass context
RenderObject Tree ✅ (получает детей через RenderContext)

Layout Flow:
┌─────────────────────────────────┐
│ PipelineOwner.layout_element()  │
└────────────┬────────────────────┘
             │
             ├─► Layout Child 1 ──┐
             │                     │
             ├─► Layout Child 2 ──┤ Bottom-up
             │                     │
             └─► Layout Child N ──┘
                                   │
                    ┌──────────────┘
                    │
                    ▼
        ┌──────────────────────────┐
        │ Layout Parent с context  │
        │ (дети уже залайаутены)   │
        └──────────────────────────┘
```

## API Изменения

### Было:

```rust
trait DynRenderObject {
    fn layout(&mut self, constraints: BoxConstraints) -> Size;
    fn paint(&self, painter: &Painter, offset: Offset);
}
```

### Стало:

```rust
trait DynRenderObject {
    fn layout(
        &mut self, 
        constraints: BoxConstraints,
        ctx: &RenderContext,  // ← НОВОЕ!
    ) -> Size;
    
    fn paint(
        &self, 
        painter: &Painter, 
        offset: Offset,
        ctx: &RenderContext,  // ← НОВОЕ!
    );
}

struct RenderContext<'a> {
    tree: &'a ElementTree,
    element_id: ElementId,
    pipeline_owner: Option<&'a PipelineOwner>,
}
```

## Сравнение с Flutter

### Flutter (Dart):

```dart
class RenderFlex extends RenderBox {
  @override
  void performLayout() {
    // Доступ к детям через mixin
    RenderBox? child = firstChild;
    while (child != null) {
      child.layout(constraints);
      child = childAfter(child);
    }
  }
}
```

**Как Flutter решает:**
- `ContainerRenderObjectMixin` управляет детьми
- Linked list через ParentData
- Garbage collector решает проблемы ownership

### Flui (Rust):

```rust
impl DynRenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints, ctx: &RenderContext) -> Size {
        // Доступ к детям через context
        let element = ctx.tree.get(ctx.element_id).unwrap();
        
        for child_id in element.children_iter() {
            let child = ctx.tree.get(child_id).unwrap();
            let size = child.render_object().unwrap().size();
            // Use size...
        }
    }
}
```

**Как Flui решает:**
- Явная передача `RenderContext` с доступом к tree
- Нет клонирования - только read access
- Borrow checker гарантирует безопасность

## Преимущества RenderContext подхода

✅ **Explicit Dependencies**: Всё что нужно RenderObject передаётся явно  
✅ **Zero Clone**: Нет копирования render objects  
✅ **Type Safe**: Compile-time проверки  
✅ **Extensible**: Легко добавлять новые поля в context  
✅ **Testable**: Mock context для unit tests  
✅ **Rust Idiomatic**: Явные параметры вместо globals/thread-locals  

## Недостатки

⚠️ **Breaking Change**: Нужно обновить все impl блоки  
⚠️ **Verbose**: Больше параметров в методах  
⚠️ **Migration**: Нужно обновить весь существующий код  

## Альтернативы (почему хуже)

### Thread-local storage:
```rust
thread_local! {
    static CURRENT_TREE: RefCell<Option<*const ElementTree>> = RefCell::new(None);
}
```
❌ Unsafe, глобальное состояние, не testable

### RefCell в ElementTree:
```rust
elements: HashMap<ElementId, RefCell<Box<dyn DynElement>>>
```
❌ Runtime overhead, может panic, не thread-safe

### Клонирование детей:
```rust
render_object.set_children(clone_children());
```
❌ Невозможно - Box<dyn Trait> не Clone

### Linked list в ParentData:
```rust
struct FlexParentData {
    next_sibling: Option<ElementId>,
}
```
❌ Сложно в Rust, не idiomatic, не улучшает архитектуру

## Вывод

**RenderContext - единственное правильное решение!**

Оно следует Rust принципам:
- Explicit over implicit
- No hidden state
- Compile-time safety
- Zero-cost abstractions (никаких clones/refcells)

Да, это breaking change, но он делает архитектуру:
- Понятнее
- Безопаснее  
- Расширяемее
- Тестируемее

**Рекомендация: Реализовать RenderContext прямо сейчас, пока кодовая база небольшая!**
