# Архитектурно Правильное Решение: Flutter-way

## Как это работает во Flutter

Во Flutter **RenderObject НЕ хранит дочерние RenderObject напрямую**. Вместо этого:

### Flutter Architecture

```dart
// Flutter RenderFlex
class RenderFlex extends RenderBox 
    with ContainerRenderObjectMixin<RenderBox, FlexParentData> {
  
  // НЕТ поля children! Оно в ContainerRenderObjectMixin!
  
  @override
  void performLayout() {
    // Доступ к детям через mixin methods:
    RenderBox? child = firstChild;
    while (child != null) {
      child.layout(constraints);
      final FlexParentData childParentData = child.parentData as FlexParentData;
      child = childParentData.nextSibling; // Linked list!
    }
  }
}
```

### Ключевые моменты Flutter подхода:

1. **ContainerRenderObjectMixin** управляет детьми
2. Дети связаны через **linked list** (не Vec!)
3. Каждый child имеет **ParentData** с указателем на `nextSibling`
4. RenderObject получает доступ к детям через `firstChild` / `lastChild`

## Применение к Flui

### Вариант 1: Linked List (как Flutter)

```rust
// ParentData содержит ссылку на следующего ребёнка
pub trait ParentData: Any + Debug + Send + Sync {
    fn next_sibling(&self) -> Option<ElementId> {
        None
    }
    
    fn set_next_sibling(&mut self, _sibling: Option<ElementId>) {
        // Override in multi-child layouts
    }
}

pub struct FlexParentData {
    pub flex: Option<u32>,
    pub fit: FlexFit,
    pub next_sibling: Option<ElementId>,
}

impl ParentData for FlexParentData {
    fn next_sibling(&self) -> Option<ElementId> {
        self.next_sibling
    }
    
    fn set_next_sibling(&mut self, sibling: Option<ElementId>) {
        self.next_sibling = sibling;
    }
}
```

```rust
// RenderFlex получает детей через linked list
impl RenderFlex {
    pub fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        // Получаем first child
        let element = tree.get(element_id).unwrap();
        let mut current_child_id = element.children_iter().next();
        
        while let Some(child_id) = current_child_id {
            let child_elem = tree.get(child_id).unwrap();
            let child_ro = child_elem.render_object_mut().unwrap();
            
            // Layout child
            let child_size = child_ro.layout(constraints);
            
            // Get next sibling from parent data
            if let Some(parent_data) = child_ro.parent_data_any() {
                if let Some(flex_pd) = parent_data.downcast_ref::<FlexParentData>() {
                    current_child_id = flex_pd.next_sibling();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        
        // Compute final size...
        self.size
    }
}
```

**Проблемы:**
- ❌ Сложно: нужно управлять linked list
- ❌ Не Rust-idiomatic (linked lists в Rust болезненны)
- ❌ Borrow checker всё равно мешает (мы пытаемся получить `&mut` несколько раз)

### Вариант 2: Передать ElementTree как параметр (РЕКОМЕНДУЕТСЯ)

Это самый простой и Rust-idiomatic способ!

```rust
// Trait для RenderObject с доступом к tree
pub trait DynRenderObject: DowncastSync + fmt::Debug {
    // Старый метод для backwards compatibility
    fn layout(&mut self, constraints: BoxConstraints) -> Size;
    
    // НОВЫЙ метод с доступом к tree!
    fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        // Default: просто вызываем layout()
        self.layout(constraints)
    }
    
    fn paint_with_tree(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        tree: &ElementTree,
        element_id: ElementId,
    ) {
        // Default: просто вызываем paint()
        self.paint(painter, offset);
    }
}
```

```rust
// RenderFlex реализует новый метод
impl DynRenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        // Fallback для случаев когда tree недоступно
        constraints.constrain(Size::zero())
    }
    
    fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        self.constraints = Some(constraints);
        
        // Получаем element
        let element = tree.get(element_id).unwrap();
        
        // Layout всех детей через tree
        let mut child_sizes = Vec::new();
        
        for child_id in element.children_iter() {
            if let Some(child_elem) = tree.get(child_id) {
                if let Some(child_ro) = child_elem.render_object() {
                    // Рекурсивно layout ребёнка
                    let child_constraints = self.compute_child_constraints(constraints);
                    
                    // ПРОБЛЕМА: нужен &mut для layout!
                    // Решение ниже...
                }
            }
        }
        
        // Compute flex layout
        self.compute_flex_layout(constraints, &child_sizes)
    }
}
```

**Проблема:** Borrow checker! Мы пытаемся получить `&mut` для child_ro но у нас только `&tree`.

### Вариант 3: Interior Mutability (RefCell для single-thread)

```rust
pub struct ElementTree {
    elements: HashMap<ElementId, RefCell<Box<dyn DynElement>>>,
    // ... остальные поля
}

impl ElementTree {
    pub fn get(&self, id: ElementId) -> Option<Ref<dyn DynElement>> {
        self.elements.get(&id).map(|e| e.borrow())
    }
    
    pub fn get_mut(&self, id: ElementId) -> Option<RefMut<dyn DynElement>> {
        self.elements.get(&id).map(|e| e.borrow_mut())
    }
}
```

```rust
impl DynRenderObject for RenderFlex {
    fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        let element = tree.get(element_id).unwrap();
        
        // Layout детей
        for child_id in element.children_iter().collect::<Vec<_>>() {
            // RefCell позволяет получить &mut даже с &tree
            if let Some(mut child_elem) = tree.get_mut(child_id) {
                if let Some(child_ro) = child_elem.render_object_mut() {
                    let child_constraints = self.compute_child_constraints(constraints);
                    child_ro.layout_with_tree(child_constraints, tree, child_id);
                }
            }
        }
        
        // Compute layout используя уже залайаутенных детей
        self.compute_flex_layout(constraints, tree, element_id)
    }
}
```

**Проблемы:**
- ❌ Runtime borrow checking overhead
- ❌ Может panic если неправильно используем
- ❌ Не работает с RwLock (который уже есть)

### Вариант 4: Two-Phase Layout (САМЫЙ ПРОСТОЙ)

Разделить layout на 2 фазы:

**Phase 1: Layout детей (bottom-up)**
```rust
fn layout_subtree(&mut self, element_id: ElementId, constraints: BoxConstraints) {
    let element = self.tree.read().get(element_id).unwrap();
    let child_ids: Vec<_> = element.children_iter().collect();
    
    // Layout всех детей ПЕРВЫМИ (рекурсивно)
    for child_id in child_ids {
        let child_elem = self.tree.read().get(child_id).unwrap();
        if let Some(child_ro) = child_elem.render_object() {
            let child_constraints = /* compute */;
            self.layout_subtree(child_id, child_constraints);
        }
    }
    
    // Теперь layout parent (дети уже готовы!)
    let mut element = self.tree.write().get_mut(element_id).unwrap();
    if let Some(ro) = element.render_object_mut() {
        ro.layout(constraints);
    }
}
```

**Phase 2: RenderObject читает размеры детей**
```rust
impl DynRenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        // На этот момент дети УЖЕ залайаутены!
        // Мы просто читаем их размеры через ElementTree
        
        // ПРОБЛЕМА: как получить доступ к tree?
        // Нужно передать как параметр!
    }
}
```

## ФИНАЛЬНОЕ АРХИТЕКТУРНОЕ РЕШЕНИЕ

Комбинация вариантов 2 и 4:

### 1. Добавить context parameter во все RenderObject методы

```rust
pub trait DynRenderObject: DowncastSync + fmt::Debug {
    /// Layout with rendering context
    fn layout(
        &mut self,
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size;
    
    /// Paint with rendering context  
    fn paint(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        ctx: &RenderContext,
    );
    
    // ... другие методы
}

/// Rendering context - всё что нужно RenderObject
pub struct RenderContext<'a> {
    /// Element tree for accessing children
    pub tree: &'a ElementTree,
    /// Current element ID
    pub element_id: ElementId,
    /// Pipeline owner (optional)
    pub pipeline_owner: Option<&'a PipelineOwner>,
}
```

### 2. RenderFlex использует context

```rust
impl DynRenderObject for RenderFlex {
    fn layout(
        &mut self,
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size {
        self.constraints = Some(constraints);
        
        // Получаем детей через context
        let element = ctx.tree.get(ctx.element_id).unwrap();
        
        // Layout logic
        let mut total_main = 0.0;
        let mut max_cross = 0.0;
        
        for child_id in element.children_iter() {
            let child_elem = ctx.tree.get(child_id).unwrap();
            
            // Читаем размер ребёнка (он УЖЕ залайаутен!)
            if let Some(child_ro) = child_elem.render_object() {
                let child_size = child_ro.size();
                
                match self.direction {
                    Axis::Horizontal => {
                        total_main += child_size.width;
                        max_cross = max_cross.max(child_size.height);
                    }
                    Axis::Vertical => {
                        total_main += child_size.height;
                        max_cross = max_cross.max(child_size.width);
                    }
                }
            }
        }
        
        // Compute final size
        let size = match self.direction {
            Axis::Horizontal => Size::new(total_main, max_cross),
            Axis::Vertical => Size::new(max_cross, total_main),
        };
        
        self.size = constraints.constrain(size);
        self.needs_layout_flag = false;
        
        self.size
    }
    
    fn paint(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        ctx: &RenderContext,
    ) {
        let element = ctx.tree.get(ctx.element_id).unwrap();
        
        let mut current_offset = offset;
        
        for child_id in element.children_iter() {
            let child_elem = ctx.tree.get(child_id).unwrap();
            
            if let Some(child_ro) = child_elem.render_object() {
                // Paint ребёнка
                child_ro.paint(painter, current_offset, ctx);
                
                // Update offset для следующего
                match self.direction {
                    Axis::Horizontal => {
                        current_offset.dx += child_ro.size().width;
                    }
                    Axis::Vertical => {
                        current_offset.dy += child_ro.size().height;
                    }
                }
            }
        }
    }
}
```

### 3. PipelineOwner вызывает с context

```rust
impl PipelineOwner {
    fn layout_element(&mut self, element_id: ElementId) {
        let tree = self.tree.read();
        
        // Layout детей ПЕРВЫМИ (bottom-up)
        if let Some(element) = tree.get(element_id) {
            for child_id in element.children_iter().collect::<Vec<_>>() {
                drop(tree); // Release read lock
                self.layout_element(child_id); // Recursive
                tree = self.tree.read(); // Re-acquire
            }
        }
        drop(tree);
        
        // Теперь layout parent
        let tree = self.tree.read();
        if let Some(element) = tree.get(element_id) {
            if let Some(mut ro) = element.render_object_mut() {
                let ctx = RenderContext {
                    tree: &tree,
                    element_id,
                    pipeline_owner: Some(self),
                };
                
                let constraints = /* get constraints */;
                ro.layout(constraints, &ctx);
            }
        }
    }
}
```

## Преимущества Финального Решения

✅ **Чистая архитектура**: RenderObject получает всё что нужно через context  
✅ **Расширяемость**: Легко добавить новые поля в RenderContext  
✅ **Эффективность**: Нет клонирования, нет RefCell overhead  
✅ **Rust-idiomatic**: Явная передача зависимостей через параметры  
✅ **Type-safe**: Всё проверяется на compile-time  
✅ **Testable**: Можно создать mock RenderContext для тестов

## Миграция

**Breaking change**, но чистый:

1. Добавить `RenderContext` struct
2. Изменить signature всех методов в `DynRenderObject`:
   - `layout(&mut self, constraints, ctx: &RenderContext)`
   - `paint(&self, painter, offset, ctx: &RenderContext)`
3. Обновить все impl блоки
4. Profit!

Это **правильное** архитектурное решение в стиле Rust! 🎉
