# –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –†–µ—à–µ–Ω–∏–µ: Flutter-way

## –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤–æ Flutter

–í–æ Flutter **RenderObject –ù–ï —Ö—Ä–∞–Ω–∏—Ç –¥–æ—á–µ—Ä–Ω–∏–µ RenderObject –Ω–∞–ø—Ä—è–º—É—é**. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ:

### Flutter Architecture

```dart
// Flutter RenderFlex
class RenderFlex extends RenderBox 
    with ContainerRenderObjectMixin<RenderBox, FlexParentData> {
  
  // –ù–ï–¢ –ø–æ–ª—è children! –û–Ω–æ –≤ ContainerRenderObjectMixin!
  
  @override
  void performLayout() {
    // –î–æ—Å—Ç—É–ø –∫ –¥–µ—Ç—è–º —á–µ—Ä–µ–∑ mixin methods:
    RenderBox? child = firstChild;
    while (child != null) {
      child.layout(constraints);
      final FlexParentData childParentData = child.parentData as FlexParentData;
      child = childParentData.nextSibling; // Linked list!
    }
  }
}
```

### –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã Flutter –ø–æ–¥—Ö–æ–¥–∞:

1. **ContainerRenderObjectMixin** —É–ø—Ä–∞–≤–ª—è–µ—Ç –¥–µ—Ç—å–º–∏
2. –î–µ—Ç–∏ —Å–≤—è–∑–∞–Ω—ã —á–µ—Ä–µ–∑ **linked list** (–Ω–µ Vec!)
3. –ö–∞–∂–¥—ã–π child –∏–º–µ–µ—Ç **ParentData** —Å —É–∫–∞–∑–∞—Ç–µ–ª–µ–º –Ω–∞ `nextSibling`
4. RenderObject –ø–æ–ª—É—á–∞–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –¥–µ—Ç—è–º —á–µ—Ä–µ–∑ `firstChild` / `lastChild`

## –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫ Flui

### –í–∞—Ä–∏–∞–Ω—Ç 1: Linked List (–∫–∞–∫ Flutter)

```rust
// ParentData —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Å—ã–ª–∫—É –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–µ–±—ë–Ω–∫–∞
pub trait ParentData: Any + Debug + Send + Sync {
    fn next_sibling(&self) -> Option<ElementId> {
        None
    }
    
    fn set_next_sibling(&mut self, _sibling: Option<ElementId>) {
        // Override in multi-child layouts
    }
}

pub struct FlexParentData {
    pub flex: Option<u32>,
    pub fit: FlexFit,
    pub next_sibling: Option<ElementId>,
}

impl ParentData for FlexParentData {
    fn next_sibling(&self) -> Option<ElementId> {
        self.next_sibling
    }
    
    fn set_next_sibling(&mut self, sibling: Option<ElementId>) {
        self.next_sibling = sibling;
    }
}
```

```rust
// RenderFlex –ø–æ–ª—É—á–∞–µ—Ç –¥–µ—Ç–µ–π —á–µ—Ä–µ–∑ linked list
impl RenderFlex {
    pub fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        // –ü–æ–ª—É—á–∞–µ–º first child
        let element = tree.get(element_id).unwrap();
        let mut current_child_id = element.children_iter().next();
        
        while let Some(child_id) = current_child_id {
            let child_elem = tree.get(child_id).unwrap();
            let child_ro = child_elem.render_object_mut().unwrap();
            
            // Layout child
            let child_size = child_ro.layout(constraints);
            
            // Get next sibling from parent data
            if let Some(parent_data) = child_ro.parent_data_any() {
                if let Some(flex_pd) = parent_data.downcast_ref::<FlexParentData>() {
                    current_child_id = flex_pd.next_sibling();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        
        // Compute final size...
        self.size
    }
}
```

**–ü—Ä–æ–±–ª–µ–º—ã:**
- ‚ùå –°–ª–æ–∂–Ω–æ: –Ω—É–∂–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å linked list
- ‚ùå –ù–µ Rust-idiomatic (linked lists –≤ Rust –±–æ–ª–µ–∑–Ω–µ–Ω–Ω—ã)
- ‚ùå Borrow checker –≤—Å—ë —Ä–∞–≤–Ω–æ –º–µ—à–∞–µ—Ç (–º—ã –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å `&mut` –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑)

### –í–∞—Ä–∏–∞–Ω—Ç 2: –ü–µ—Ä–µ–¥–∞—Ç—å ElementTree –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä (–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø)

–≠—Ç–æ —Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π –∏ Rust-idiomatic —Å–ø–æ—Å–æ–±!

```rust
// Trait –¥–ª—è RenderObject —Å –¥–æ—Å—Ç—É–ø–æ–º –∫ tree
pub trait DynRenderObject: DowncastSync + fmt::Debug {
    // –°—Ç–∞—Ä—ã–π –º–µ—Ç–æ–¥ –¥–ª—è backwards compatibility
    fn layout(&mut self, constraints: BoxConstraints) -> Size;
    
    // –ù–û–í–´–ô –º–µ—Ç–æ–¥ —Å –¥–æ—Å—Ç—É–ø–æ–º –∫ tree!
    fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        // Default: –ø—Ä–æ—Å—Ç–æ –≤—ã–∑—ã–≤–∞–µ–º layout()
        self.layout(constraints)
    }
    
    fn paint_with_tree(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        tree: &ElementTree,
        element_id: ElementId,
    ) {
        // Default: –ø—Ä–æ—Å—Ç–æ –≤—ã–∑—ã–≤–∞–µ–º paint()
        self.paint(painter, offset);
    }
}
```

```rust
// RenderFlex —Ä–µ–∞–ª–∏–∑—É–µ—Ç –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥
impl DynRenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        // Fallback –¥–ª—è —Å–ª—É—á–∞–µ–≤ –∫–æ–≥–¥–∞ tree –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ
        constraints.constrain(Size::zero())
    }
    
    fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        self.constraints = Some(constraints);
        
        // –ü–æ–ª—É—á–∞–µ–º element
        let element = tree.get(element_id).unwrap();
        
        // Layout –≤—Å–µ—Ö –¥–µ—Ç–µ–π —á–µ—Ä–µ–∑ tree
        let mut child_sizes = Vec::new();
        
        for child_id in element.children_iter() {
            if let Some(child_elem) = tree.get(child_id) {
                if let Some(child_ro) = child_elem.render_object() {
                    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ layout —Ä–µ–±—ë–Ω–∫–∞
                    let child_constraints = self.compute_child_constraints(constraints);
                    
                    // –ü–†–û–ë–õ–ï–ú–ê: –Ω—É–∂–µ–Ω &mut –¥–ª—è layout!
                    // –†–µ—à–µ–Ω–∏–µ –Ω–∏–∂–µ...
                }
            }
        }
        
        // Compute flex layout
        self.compute_flex_layout(constraints, &child_sizes)
    }
}
```

**–ü—Ä–æ–±–ª–µ–º–∞:** Borrow checker! –ú—ã –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å `&mut` –¥–ª—è child_ro –Ω–æ —É –Ω–∞—Å —Ç–æ–ª—å–∫–æ `&tree`.

### –í–∞—Ä–∏–∞–Ω—Ç 3: Interior Mutability (RefCell –¥–ª—è single-thread)

```rust
pub struct ElementTree {
    elements: HashMap<ElementId, RefCell<Box<dyn DynElement>>>,
    // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è
}

impl ElementTree {
    pub fn get(&self, id: ElementId) -> Option<Ref<dyn DynElement>> {
        self.elements.get(&id).map(|e| e.borrow())
    }
    
    pub fn get_mut(&self, id: ElementId) -> Option<RefMut<dyn DynElement>> {
        self.elements.get(&id).map(|e| e.borrow_mut())
    }
}
```

```rust
impl DynRenderObject for RenderFlex {
    fn layout_with_tree(
        &mut self,
        constraints: BoxConstraints,
        tree: &ElementTree,
        element_id: ElementId,
    ) -> Size {
        let element = tree.get(element_id).unwrap();
        
        // Layout –¥–µ—Ç–µ–π
        for child_id in element.children_iter().collect::<Vec<_>>() {
            // RefCell –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ–ª—É—á–∏—Ç—å &mut –¥–∞–∂–µ —Å &tree
            if let Some(mut child_elem) = tree.get_mut(child_id) {
                if let Some(child_ro) = child_elem.render_object_mut() {
                    let child_constraints = self.compute_child_constraints(constraints);
                    child_ro.layout_with_tree(child_constraints, tree, child_id);
                }
            }
        }
        
        // Compute layout –∏—Å–ø–æ–ª—å–∑—É—è —É–∂–µ –∑–∞–ª–∞–π–∞—É—Ç–µ–Ω–Ω—ã—Ö –¥–µ—Ç–µ–π
        self.compute_flex_layout(constraints, tree, element_id)
    }
}
```

**–ü—Ä–æ–±–ª–µ–º—ã:**
- ‚ùå Runtime borrow checking overhead
- ‚ùå –ú–æ–∂–µ—Ç panic –µ—Å–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º
- ‚ùå –ù–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å RwLock (–∫–æ—Ç–æ—Ä—ã–π —É–∂–µ –µ—Å—Ç—å)

### –í–∞—Ä–∏–∞–Ω—Ç 4: Two-Phase Layout (–°–ê–ú–´–ô –ü–†–û–°–¢–û–ô)

–†–∞–∑–¥–µ–ª–∏—Ç—å layout –Ω–∞ 2 —Ñ–∞–∑—ã:

**Phase 1: Layout –¥–µ—Ç–µ–π (bottom-up)**
```rust
fn layout_subtree(&mut self, element_id: ElementId, constraints: BoxConstraints) {
    let element = self.tree.read().get(element_id).unwrap();
    let child_ids: Vec<_> = element.children_iter().collect();
    
    // Layout –≤—Å–µ—Ö –¥–µ—Ç–µ–π –ü–ï–†–í–´–ú–ò (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ)
    for child_id in child_ids {
        let child_elem = self.tree.read().get(child_id).unwrap();
        if let Some(child_ro) = child_elem.render_object() {
            let child_constraints = /* compute */;
            self.layout_subtree(child_id, child_constraints);
        }
    }
    
    // –¢–µ–ø–µ—Ä—å layout parent (–¥–µ—Ç–∏ —É–∂–µ –≥–æ—Ç–æ–≤—ã!)
    let mut element = self.tree.write().get_mut(element_id).unwrap();
    if let Some(ro) = element.render_object_mut() {
        ro.layout(constraints);
    }
}
```

**Phase 2: RenderObject —á–∏—Ç–∞–µ—Ç —Ä–∞–∑–º–µ—Ä—ã –¥–µ—Ç–µ–π**
```rust
impl DynRenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        // –ù–∞ —ç—Ç–æ—Ç –º–æ–º–µ–Ω—Ç –¥–µ—Ç–∏ –£–ñ–ï –∑–∞–ª–∞–π–∞—É—Ç–µ–Ω—ã!
        // –ú—ã –ø—Ä–æ—Å—Ç–æ —á–∏—Ç–∞–µ–º –∏—Ö —Ä–∞–∑–º–µ—Ä—ã —á–µ—Ä–µ–∑ ElementTree
        
        // –ü–†–û–ë–õ–ï–ú–ê: –∫–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ tree?
        // –ù—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä!
    }
}
```

## –§–ò–ù–ê–õ–¨–ù–û–ï –ê–†–•–ò–¢–ï–ö–¢–£–†–ù–û–ï –†–ï–®–ï–ù–ò–ï

–ö–æ–º–±–∏–Ω–∞—Ü–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ 2 –∏ 4:

### 1. –î–æ–±–∞–≤–∏—Ç—å context parameter –≤–æ –≤—Å–µ RenderObject –º–µ—Ç–æ–¥—ã

```rust
pub trait DynRenderObject: DowncastSync + fmt::Debug {
    /// Layout with rendering context
    fn layout(
        &mut self,
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size;
    
    /// Paint with rendering context  
    fn paint(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        ctx: &RenderContext,
    );
    
    // ... –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã
}

/// Rendering context - –≤—Å—ë —á—Ç–æ –Ω—É–∂–Ω–æ RenderObject
pub struct RenderContext<'a> {
    /// Element tree for accessing children
    pub tree: &'a ElementTree,
    /// Current element ID
    pub element_id: ElementId,
    /// Pipeline owner (optional)
    pub pipeline_owner: Option<&'a PipelineOwner>,
}
```

### 2. RenderFlex –∏—Å–ø–æ–ª—å–∑—É–µ—Ç context

```rust
impl DynRenderObject for RenderFlex {
    fn layout(
        &mut self,
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size {
        self.constraints = Some(constraints);
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–µ–π —á–µ—Ä–µ–∑ context
        let element = ctx.tree.get(ctx.element_id).unwrap();
        
        // Layout logic
        let mut total_main = 0.0;
        let mut max_cross = 0.0;
        
        for child_id in element.children_iter() {
            let child_elem = ctx.tree.get(child_id).unwrap();
            
            // –ß–∏—Ç–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ä–µ–±—ë–Ω–∫–∞ (–æ–Ω –£–ñ–ï –∑–∞–ª–∞–π–∞—É—Ç–µ–Ω!)
            if let Some(child_ro) = child_elem.render_object() {
                let child_size = child_ro.size();
                
                match self.direction {
                    Axis::Horizontal => {
                        total_main += child_size.width;
                        max_cross = max_cross.max(child_size.height);
                    }
                    Axis::Vertical => {
                        total_main += child_size.height;
                        max_cross = max_cross.max(child_size.width);
                    }
                }
            }
        }
        
        // Compute final size
        let size = match self.direction {
            Axis::Horizontal => Size::new(total_main, max_cross),
            Axis::Vertical => Size::new(max_cross, total_main),
        };
        
        self.size = constraints.constrain(size);
        self.needs_layout_flag = false;
        
        self.size
    }
    
    fn paint(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        ctx: &RenderContext,
    ) {
        let element = ctx.tree.get(ctx.element_id).unwrap();
        
        let mut current_offset = offset;
        
        for child_id in element.children_iter() {
            let child_elem = ctx.tree.get(child_id).unwrap();
            
            if let Some(child_ro) = child_elem.render_object() {
                // Paint —Ä–µ–±—ë–Ω–∫–∞
                child_ro.paint(painter, current_offset, ctx);
                
                // Update offset –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ
                match self.direction {
                    Axis::Horizontal => {
                        current_offset.dx += child_ro.size().width;
                    }
                    Axis::Vertical => {
                        current_offset.dy += child_ro.size().height;
                    }
                }
            }
        }
    }
}
```

### 3. PipelineOwner –≤—ã–∑—ã–≤–∞–µ—Ç —Å context

```rust
impl PipelineOwner {
    fn layout_element(&mut self, element_id: ElementId) {
        let tree = self.tree.read();
        
        // Layout –¥–µ—Ç–µ–π –ü–ï–†–í–´–ú–ò (bottom-up)
        if let Some(element) = tree.get(element_id) {
            for child_id in element.children_iter().collect::<Vec<_>>() {
                drop(tree); // Release read lock
                self.layout_element(child_id); // Recursive
                tree = self.tree.read(); // Re-acquire
            }
        }
        drop(tree);
        
        // –¢–µ–ø–µ—Ä—å layout parent
        let tree = self.tree.read();
        if let Some(element) = tree.get(element_id) {
            if let Some(mut ro) = element.render_object_mut() {
                let ctx = RenderContext {
                    tree: &tree,
                    element_id,
                    pipeline_owner: Some(self),
                };
                
                let constraints = /* get constraints */;
                ro.layout(constraints, &ctx);
            }
        }
    }
}
```

## –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –§–∏–Ω–∞–ª—å–Ω–æ–≥–æ –†–µ—à–µ–Ω–∏—è

‚úÖ **–ß–∏—Å—Ç–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**: RenderObject –ø–æ–ª—É—á–∞–µ—Ç –≤—Å—ë —á—Ç–æ –Ω—É–∂–Ω–æ —á–µ—Ä–µ–∑ context  
‚úÖ **–†–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ –ø–æ–ª—è –≤ RenderContext  
‚úÖ **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å**: –ù–µ—Ç –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–µ—Ç RefCell overhead  
‚úÖ **Rust-idiomatic**: –Ø–≤–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π —á–µ—Ä–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã  
‚úÖ **Type-safe**: –í—Å—ë –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –Ω–∞ compile-time  
‚úÖ **Testable**: –ú–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å mock RenderContext –¥–ª—è —Ç–µ—Å—Ç–æ–≤

## –ú–∏–≥—Ä–∞—Ü–∏—è

**Breaking change**, –Ω–æ —á–∏—Å—Ç—ã–π:

1. –î–æ–±–∞–≤–∏—Ç—å `RenderContext` struct
2. –ò–∑–º–µ–Ω–∏—Ç—å signature –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤ –≤ `DynRenderObject`:
   - `layout(&mut self, constraints, ctx: &RenderContext)`
   - `paint(&self, painter, offset, ctx: &RenderContext)`
3. –û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ impl –±–ª–æ–∫–∏
4. Profit!

–≠—Ç–æ **–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ** –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –≤ —Å—Ç–∏–ª–µ Rust! üéâ
