# План Миграции на RenderContext Архитектуру

## Шаг 0: Подготовка (анализ масштаба изменений)

### Найти все impl DynRenderObject

```bash
# Найти все файлы с impl DynRenderObject
rg "impl.*DynRenderObject" --type rust

# Ожидаемые файлы:
# - crates/flui_rendering/src/render_flex.rs
# - crates/flui_rendering/src/objects/layout/*.rs
# - crates/flui_rendering/src/objects/visual/*.rs
# - crates/flui_core/src/render/*.rs
```

### Оценка:
- ~10-20 impl блоков для обновления
- ~50-100 мест где вызывается layout/paint
- Время: 2-4 часа работы

## Шаг 1: Создать RenderContext (новый файл)

**Файл:** `crates/flui_core/src/render/render_context.rs`

```rust
//! Rendering context for RenderObject operations
//!
//! Provides access to ElementTree and other resources needed during
//! layout and paint operations.

use std::sync::Arc;
use parking_lot::RwLock;

use crate::{ElementId, ElementTree, PipelineOwner};

/// Rendering context passed to RenderObject during layout/paint
///
/// Provides access to:
/// - Element tree for accessing children
/// - Current element ID
/// - Pipeline owner (optional)
///
/// # Example
///
/// ```rust,ignore
/// fn layout(&mut self, constraints: BoxConstraints, ctx: &RenderContext) -> Size {
///     // Access children through tree
///     let element = ctx.tree.read().get(ctx.element_id).unwrap();
///     for child_id in element.children_iter() {
///         let child = ctx.tree.read().get(child_id).unwrap();
///         // Process child...
///     }
/// }
/// ```
#[derive(Clone)]
pub struct RenderContext {
    /// Element tree for accessing children
    tree: Arc<RwLock<ElementTree>>,
    
    /// Current element ID
    element_id: ElementId,
    
    /// Pipeline owner (optional, for scheduling)
    pipeline_owner: Option<Arc<RwLock<PipelineOwner>>>,
}

impl RenderContext {
    /// Create a new render context
    pub fn new(
        tree: Arc<RwLock<ElementTree>>,
        element_id: ElementId,
    ) -> Self {
        Self {
            tree,
            element_id,
            pipeline_owner: None,
        }
    }
    
    /// Create with pipeline owner
    pub fn with_owner(
        tree: Arc<RwLock<ElementTree>>,
        element_id: ElementId,
        pipeline_owner: Arc<RwLock<PipelineOwner>>,
    ) -> Self {
        Self {
            tree,
            element_id,
            pipeline_owner: Some(pipeline_owner),
        }
    }
    
    /// Get the element tree
    #[inline]
    pub fn tree(&self) -> &Arc<RwLock<ElementTree>> {
        &self.tree
    }
    
    /// Get the current element ID
    #[inline]
    pub fn element_id(&self) -> ElementId {
        self.element_id
    }
    
    /// Get the pipeline owner (if available)
    #[inline]
    pub fn pipeline_owner(&self) -> Option<&Arc<RwLock<PipelineOwner>>> {
        self.pipeline_owner.as_ref()
    }
}

impl std::fmt::Debug for RenderContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RenderContext")
            .field("element_id", &self.element_id)
            .field("has_pipeline_owner", &self.pipeline_owner.is_some())
            .finish()
    }
}
```

**Добавить в mod.rs:**

```rust
// crates/flui_core/src/render/mod.rs
mod render_context;
pub use render_context::RenderContext;
```

## Шаг 2: Обновить DynRenderObject trait (breaking change)

**Файл:** `crates/flui_core/src/render/dyn_render_object.rs`

### 2.1 Изменить signature методов

```rust
pub trait DynRenderObject: DowncastSync + fmt::Debug {
    // ========== БЫЛО ==========
    // fn layout(&mut self, constraints: BoxConstraints) -> Size;
    // fn paint(&self, painter: &egui::Painter, offset: Offset);
    
    // ========== СТАЛО ==========
    
    /// Perform layout with rendering context
    fn layout(
        &mut self,
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size;
    
    /// Paint this render object with rendering context
    fn paint(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        ctx: &RenderContext,
    );
    
    // Остальные методы без изменений...
}
```

### 2.2 Обновить default implementations (если есть)

Все default impl также должны принимать `ctx`.

## Шаг 3: Обновить все impl блоки (самая большая работа)

### Паттерн для leaf render objects (без детей):

```rust
// БЫЛО:
impl DynRenderObject for RenderText {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        // layout logic
        self.size
    }
    
    fn paint(&self, painter: &Painter, offset: Offset) {
        // paint logic
    }
}

// СТАЛО:
impl DynRenderObject for RenderText {
    fn layout(
        &mut self, 
        constraints: BoxConstraints,
        _ctx: &RenderContext,  // ← underscore если не используем
    ) -> Size {
        // layout logic без изменений
        self.size
    }
    
    fn paint(
        &self, 
        painter: &Painter, 
        offset: Offset,
        _ctx: &RenderContext,  // ← underscore если не используем
    ) {
        // paint logic без изменений
    }
}
```

### Паттерн для single-child render objects:

```rust
// БЫЛО:
impl DynRenderObject for RenderPadding {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        if let Some(child) = &mut self.child {
            let child_constraints = /* compute */;
            child.layout(child_constraints);
            // use child.size()
        }
        self.size
    }
}

// СТАЛО:
impl DynRenderObject for RenderPadding {
    fn layout(
        &mut self, 
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size {
        // Получаем child через tree
        let tree = ctx.tree().read();
        let element = tree.get(ctx.element_id()).unwrap();
        
        if let Some(child_id) = element.children_iter().next() {
            let child_elem = tree.get(child_id).unwrap();
            if let Some(child_ro) = child_elem.render_object() {
                let child_size = child_ro.size();
                // use child_size...
            }
        }
        
        self.size
    }
}
```

### Паттерн для multi-child render objects (RenderFlex):

```rust
impl DynRenderObject for RenderFlex {
    fn layout(
        &mut self,
        constraints: BoxConstraints,
        ctx: &RenderContext,
    ) -> Size {
        self.constraints = Some(constraints);
        
        // Получаем element и его детей
        let tree = ctx.tree().read();
        let element = tree.get(ctx.element_id()).unwrap();
        
        let mut total_main = 0.0;
        let mut max_cross = 0.0;
        
        // Итерируем детей
        for child_id in element.children_iter() {
            if let Some(child_elem) = tree.get(child_id) {
                if let Some(child_ro) = child_elem.render_object() {
                    let child_size = child_ro.size();
                    
                    match self.direction {
                        Axis::Horizontal => {
                            total_main += child_size.width;
                            max_cross = max_cross.max(child_size.height);
                        }
                        Axis::Vertical => {
                            total_main += child_size.height;
                            max_cross = max_cross.max(child_size.width);
                        }
                    }
                }
            }
        }
        
        // Compute final size
        let size = match self.direction {
            Axis::Horizontal => Size::new(total_main, max_cross),
            Axis::Vertical => Size::new(max_cross, total_main),
        };
        
        self.size = constraints.constrain(size);
        self.needs_layout_flag = false;
        
        self.size
    }
    
    fn paint(
        &self,
        painter: &egui::Painter,
        offset: Offset,
        ctx: &RenderContext,
    ) {
        let tree = ctx.tree().read();
        let element = tree.get(ctx.element_id()).unwrap();
        
        let mut current_offset = offset;
        
        for child_id in element.children_iter() {
            if let Some(child_elem) = tree.get(child_id) {
                if let Some(child_ro) = child_elem.render_object() {
                    // Paint child
                    child_ro.paint(painter, current_offset, ctx);
                    
                    // Update offset
                    match self.direction {
                        Axis::Horizontal => {
                            current_offset.dx += child_ro.size().width;
                        }
                        Axis::Vertical => {
                            current_offset.dy += child_ro.size().height;
                        }
                    }
                }
            }
        }
    }
}
```

## Шаг 4: Обновить PipelineOwner

**Файл:** `crates/flui_core/src/tree/pipeline.rs`

```rust
impl PipelineOwner {
    pub fn flush_layout(&mut self) {
        // Сортируем по depth (parents после children)
        self.nodes_needing_layout.sort_by_key(|id| {
            self.tree.read()
                .get(*id)
                .map(|e| e.depth())
                .unwrap_or(0)
        });
        
        // Layout каждого node
        for element_id in self.nodes_needing_layout.drain(..) {
            self.layout_element(element_id);
        }
    }
    
    fn layout_element(&mut self, element_id: ElementId) {
        // Создаём context
        let ctx = RenderContext::new(
            self.tree.clone(),
            element_id,
        );
        
        // Layout element
        let tree = self.tree.read();
        if let Some(element) = tree.get(element_id) {
            if let Some(mut ro) = element.render_object_mut() {
                let constraints = /* get constraints somehow */;
                ro.layout(constraints, &ctx);
            }
        }
    }
    
    pub fn flush_paint(&mut self, painter: &egui::Painter) {
        for element_id in &self.nodes_needing_paint {
            self.paint_element(*element_id, painter);
        }
        self.nodes_needing_paint.clear();
    }
    
    fn paint_element(&self, element_id: ElementId, painter: &egui::Painter) {
        // Создаём context
        let ctx = RenderContext::new(
            self.tree.clone(),
            element_id,
        );
        
        let tree = self.tree.read();
        if let Some(element) = tree.get(element_id) {
            if let Some(ro) = element.render_object() {
                ro.paint(painter, Offset::zero(), &ctx);
            }
        }
    }
}
```

## Шаг 5: Обновить тесты

Все тесты которые вызывают `layout()` или `paint()` нужно обновить:

```rust
// БЫЛО:
let size = render_object.layout(constraints);

// СТАЛО:
let tree = Arc::new(RwLock::new(ElementTree::new()));
let element_id = ElementId::new();
let ctx = RenderContext::new(tree, element_id);
let size = render_object.layout(constraints, &ctx);
```

## Шаг 6: Обновить документацию

- README с объяснением RenderContext
- Примеры кода
- Architecture документы

## Порядок выполнения (чтобы код компилировался)

1. ✅ Создать `RenderContext` (новый файл, не ломает код)
2. ✅ Обновить `DynRenderObject` trait (breaking change, код перестанет компилироваться)
3. 🔄 Обновить **ВСЕ** impl блоки (пока все не обновлены, код не скомпилируется)
4. ✅ Обновить `PipelineOwner`
5. ✅ Обновить тесты
6. ✅ Проверить что всё работает
7. ✅ Обновить документацию

## Автоматизация

### Скрипт для поиска всех impl блоков:

```bash
#!/bin/bash
# find_render_impls.sh

echo "Finding all DynRenderObject implementations..."
rg "impl.*DynRenderObject\s+for\s+(\w+)" --type rust -o -r '$1' | sort | uniq

echo -e "\nFiles to update:"
rg "impl.*DynRenderObject" --type rust -l
```

### Checklist для каждого impl блока:

```markdown
- [ ] RenderText
- [ ] RenderFlex
- [ ] RenderPadding
- [ ] RenderOpacity
- [ ] RenderTransform
- [ ] RenderClipRect
- [ ] ... (добавить все найденные)
```

## Время оценка

- Шаг 1 (RenderContext): 15 минут
- Шаг 2 (DynRenderObject trait): 10 минут
- Шаг 3 (все impl блоки): 2-3 часа (в зависимости от количества)
- Шаг 4 (PipelineOwner): 30 минут
- Шаг 5 (тесты): 1 час
- Шаг 6 (документация): 30 минут

**Итого: 4-5 часов работы**

## После миграции

✅ RenderFlex получает доступ к детям через context  
✅ Чистая архитектура без хаков  
✅ Расширяемость (легко добавить поля в RenderContext)  
✅ Тестируемость (можно создать mock context)  

Готово к дальнейшему развитию! 🎉
