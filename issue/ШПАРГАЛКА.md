# Шпаргалка: RenderContext Migration

## Quick Start

### 1. Создать RenderContext (5 минут)

**Файл:** `crates/flui_core/src/render/render_context.rs`

```rust
use std::sync::Arc;
use parking_lot::RwLock;
use crate::{ElementId, ElementTree};

#[derive(Clone)]
pub struct RenderContext {
    tree: Arc<RwLock<ElementTree>>,
    element_id: ElementId,
}

impl RenderContext {
    pub fn new(tree: Arc<RwLock<ElementTree>>, element_id: ElementId) -> Self {
        Self { tree, element_id }
    }
    
    #[inline]
    pub fn tree(&self) -> &Arc<RwLock<ElementTree>> { &self.tree }
    
    #[inline]
    pub fn element_id(&self) -> ElementId { self.element_id }
}
```

### 2. Обновить DynRenderObject trait

```rust
pub trait DynRenderObject: DowncastSync + fmt::Debug {
    fn layout(&mut self, constraints: BoxConstraints, ctx: &RenderContext) -> Size;
    fn paint(&self, painter: &egui::Painter, offset: Offset, ctx: &RenderContext);
    // ... other methods unchanged
}
```

### 3. Паттерны для impl блоков

#### Leaf (no children):
```rust
impl DynRenderObject for RenderText {
    fn layout(&mut self, constraints: BoxConstraints, _ctx: &RenderContext) -> Size {
        // Unchanged - just add _ctx parameter
        self.size
    }
    
    fn paint(&self, painter: &Painter, offset: Offset, _ctx: &RenderContext) {
        // Unchanged
    }
}
```

#### Single Child:
```rust
impl DynRenderObject for RenderPadding {
    fn layout(&mut self, constraints: BoxConstraints, ctx: &RenderContext) -> Size {
        let tree = ctx.tree().read();
        let element = tree.get(ctx.element_id()).unwrap();
        
        if let Some(child_id) = element.children_iter().next() {
            let child = tree.get(child_id).unwrap();
            let child_size = child.render_object().unwrap().size();
            // Use child_size...
        }
        
        self.size
    }
}
```

#### Multi Child (RenderFlex):
```rust
impl DynRenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints, ctx: &RenderContext) -> Size {
        let tree = ctx.tree().read();
        let element = tree.get(ctx.element_id()).unwrap();
        
        let mut total = 0.0;
        for child_id in element.children_iter() {
            let child = tree.get(child_id).unwrap();
            total += child.render_object().unwrap().size().width;
        }
        
        self.size = constraints.constrain(Size::new(total, 0.0));
        self.size
    }
    
    fn paint(&self, painter: &Painter, offset: Offset, ctx: &RenderContext) {
        let tree = ctx.tree().read();
        let element = tree.get(ctx.element_id()).unwrap();
        
        let mut current_offset = offset;
        for child_id in element.children_iter() {
            let child = tree.get(child_id).unwrap();
            let child_ro = child.render_object().unwrap();
            child_ro.paint(painter, current_offset, ctx);
            current_offset.dx += child_ro.size().width;
        }
    }
}
```

### 4. Обновить PipelineOwner

```rust
fn layout_element(&mut self, element_id: ElementId) {
    let ctx = RenderContext::new(self.tree.clone(), element_id);
    
    let tree = self.tree.read();
    if let Some(element) = tree.get(element_id) {
        if let Some(mut ro) = element.render_object_mut() {
            ro.layout(constraints, &ctx);
        }
    }
}

fn paint_element(&self, element_id: ElementId, painter: &Painter) {
    let ctx = RenderContext::new(self.tree.clone(), element_id);
    
    let tree = self.tree.read();
    if let Some(element) = tree.get(element_id) {
        if let Some(ro) = element.render_object() {
            ro.paint(painter, Offset::zero(), &ctx);
        }
    }
}
```

## Поиск всех impl блоков

```bash
# Найти все RenderObject types
rg "impl.*DynRenderObject\s+for\s+(\w+)" -r '$1' -o | sort | uniq

# Найти все файлы для обновления
rg "impl.*DynRenderObject" -l

# Проверить compilation errors
cargo check 2>&1 | grep "expected.*found"
```

## Checklist

```markdown
### Шаг 1: Подготовка
- [ ] Создать RenderContext
- [ ] Обновить trait DynRenderObject
- [ ] Код перестал компилироваться ✅ (это нормально!)

### Шаг 2: Миграция impl блоков
- [ ] RenderText (leaf)
- [ ] RenderImage (leaf)
- [ ] RenderFlex (multi-child)
- [ ] RenderPadding (single-child)
- [ ] RenderOpacity (single-child)
- [ ] ... (добавить все найденные)

### Шаг 3: Инфраструктура
- [ ] PipelineOwner::layout_element
- [ ] PipelineOwner::paint_element
- [ ] Другие места вызова layout/paint

### Шаг 4: Тесты
- [ ] Обновить все тесты
- [ ] cargo test проходит

### Шаг 5: Документация
- [ ] README
- [ ] Примеры
- [ ] Architecture docs
```

## Типичные ошибки

### ❌ Забыли параметр ctx:
```rust
fn layout(&mut self, constraints: BoxConstraints) -> Size {
    //       ^^^^^^^^^^ compilation error!
}
```

### ✅ Правильно:
```rust
fn layout(&mut self, constraints: BoxConstraints, _ctx: &RenderContext) -> Size {
    //                                              ^^^^^^^^^^^^^^^^^^^^
}
```

### ❌ Пытаемся хранить дочерние RenderObjects:
```rust
self.children.push(child_render_object); // ❌ не Clone!
```

### ✅ Правильно - через tree:
```rust
let tree = ctx.tree().read();
for child_id in element.children_iter() {
    let child = tree.get(child_id).unwrap();
    // Используем child
}
```

## Автоматизация

### Скрипт для проверки прогресса:

```bash
#!/bin/bash
# check_migration.sh

echo "=== Compilation Status ==="
cargo check 2>&1 | tail -5

echo -e "\n=== Remaining Errors ==="
cargo check 2>&1 | grep -c "expected.*RenderContext"

echo -e "\n=== Updated Files ==="
rg "fn layout.*RenderContext" -l | wc -l
echo "out of"
rg "impl.*DynRenderObject" -l | wc -l
echo "total files"
```

## После Миграции

✅ Все тесты проходят  
✅ RenderFlex получает доступ к детям  
✅ Чистая архитектура  
✅ Готово к дальнейшему развитию

## Полезные Команды

```bash
# Компиляция с подробными ошибками
RUSTFLAGS="-Z macro-backtrace" cargo check

# Обновить только один пакет
cargo check -p flui_core

# Запустить тесты для одного модуля
cargo test --package flui_core --lib render

# Проверить форматирование
cargo fmt --check
```
