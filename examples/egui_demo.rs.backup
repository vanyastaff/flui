//! Egui Standalone Demo
//!
//! Demonstrates rendering using the egui backend.
//!
//! Run with: cargo run --example egui_demo --features flui_engine/egui

use flui_engine::{EguiPainter, Painter, Paint, RRect};
use flui_types::{Rect, Point, Offset, Size};
use std::time::Instant;

fn main() {
    env_logger::init();

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1200.0, 900.0])
            .with_title("Flui Egui Demo - CPU Rendering"),
        ..Default::default()
    };

    let _ = eframe::run_native(
        "Flui Egui Demo",
        options,
        Box::new(|_cc| Ok(Box::new(DemoApp::new()))),
    );
}

struct DemoApp {
    start_time: Instant,
    frame: u32,
    frame_times: Vec<f32>,
    last_frame_time: Instant,
}

impl DemoApp {
    fn new() -> Self {
        Self {
            start_time: Instant::now(),
            frame: 0,
            frame_times: Vec::with_capacity(60),
            last_frame_time: Instant::now(),
        }
    }

    fn calculate_fps(&mut self) -> f32 {
        let now = Instant::now();
        let frame_time = now.duration_since(self.last_frame_time).as_secs_f32();
        self.last_frame_time = now;

        self.frame_times.push(frame_time);
        if self.frame_times.len() > 60 {
            self.frame_times.remove(0);
        }

        if !self.frame_times.is_empty() {
            let avg = self.frame_times.iter().sum::<f32>() / self.frame_times.len() as f32;
            if avg > 0.0 { 1.0 / avg } else { 0.0 }
        } else {
            0.0
        }
    }
}

impl eframe::App for DemoApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        let fps = self.calculate_fps();
        let time = self.start_time.elapsed().as_secs_f32();
        self.frame += 1;

        // Request continuous repaint for smooth animation
        ctx.request_repaint();

        egui::CentralPanel::default().show(ctx, |ui| {
            // Get painter from egui
            let painter = ui.painter();
            let mut flui_painter = EguiPainter::new(painter);

            // Draw all demo shapes
            draw_demo_shapes(&mut flui_painter, self.frame, fps, time);
        });
    }
}

/// Draw demo shapes with animation
fn draw_demo_shapes(painter: &mut EguiPainter, frame: u32, fps: f32, time: f32) {
    // Title text with shadow effect
    draw_text_with_shadow(
        painter,
        "Flui Egui - CPU Rendering (No Transform Support)",
        Point::new(30.0, 25.0),
        36.0,
        [1.0, 1.0, 1.0, 1.0],
    );

    // FPS counter
    painter.text(
        &format!("FPS: {:.1} | Frame: {} | Backend: egui | Press ESC to exit", fps, frame),
        Point::new(20.0, 860.0),
        14.0,
        &Paint {
            color: [0.7, 0.7, 0.7, 1.0],
            ..Default::default()
        },
    );

    // Section 1: Text Rendering
    painter.text(
        "1. TEXT RENDERING",
        Point::new(30.0, 90.0),
        24.0,
        &Paint { color: [1.0, 1.0, 0.0, 1.0], ..Default::default() },
    );

    // Various text sizes
    painter.text("Small text (12px)", Point::new(30.0, 125.0), 12.0,
        &Paint { color: [0.8, 0.8, 0.8, 1.0], ..Default::default() });
    painter.text("Medium text (18px)", Point::new(30.0, 145.0), 18.0,
        &Paint { color: [0.9, 0.9, 0.9, 1.0], ..Default::default() });
    painter.text("Large text (28px)", Point::new(30.0, 170.0), 28.0,
        &Paint { color: [1.0, 1.0, 1.0, 1.0], ..Default::default() });

    // Animated pulsing text
    let pulse = (time * 2.0).sin() * 0.3 + 0.7;
    painter.text("Pulsing animated text", Point::new(30.0, 210.0), 20.0,
        &Paint { color: [1.0, pulse, pulse, 1.0], ..Default::default() });

    // Section 2: Shadow Effects
    painter.text(
        "2. SHADOW EFFECTS",
        Point::new(400.0, 90.0),
        24.0,
        &Paint { color: [1.0, 1.0, 0.0, 1.0], ..Default::default() },
    );

    // Drop shadow
    draw_rect_with_shadow(
        painter,
        Rect::from_xywh(400.0, 125.0, 150.0, 80.0),
        [0.2, 0.6, 1.0, 1.0],
        5.0, 5.0,
    );
    painter.text("Drop Shadow", Point::new(430.0, 155.0), 14.0,
        &Paint { color: [1.0, 1.0, 1.0, 1.0], ..Default::default() });

    // Soft glow (simplified - no real radial gradient in egui)
    draw_circle_with_glow(
        painter,
        Point::new(650.0, 165.0),
        30.0,
        [1.0, 0.5, 0.0, 1.0],
    );
    painter.text("Soft Glow", Point::new(610.0, 210.0), 14.0,
        &Paint { color: [0.8, 0.8, 0.8, 1.0], ..Default::default() });

    // Section 3: Gradients (simulated with multiple rects)
    painter.text(
        "3. GRADIENTS (Simulated)",
        Point::new(800.0, 90.0),
        24.0,
        &Paint { color: [1.0, 1.0, 0.0, 1.0], ..Default::default() },
    );

    // Horizontal gradient
    draw_horizontal_gradient(
        painter,
        Rect::from_xywh(800.0, 125.0, 150.0, 40.0),
        [1.0, 0.0, 0.0, 1.0],
        [0.0, 0.0, 1.0, 1.0],
        50,
    );

    // Vertical gradient
    draw_vertical_gradient(
        painter,
        Rect::from_xywh(800.0, 175.0, 150.0, 40.0),
        [0.0, 1.0, 0.0, 1.0],
        [1.0, 1.0, 0.0, 1.0],
        60,
    );

    // Section 4: CPU TRANSFORMS (NOW SUPPORTED!)
    painter.text(
        "4. CPU TRANSFORMS - NOW SUPPORTED!",
        Point::new(30.0, 280.0),
        24.0,
        &Paint { color: [0.0, 1.0, 0.5, 1.0], ..Default::default() },
    );

    // Rotating square
    let rotation_angle = time * 1.5;
    painter.save();
    painter.translate(Offset::new(100.0, 360.0));
    painter.rotate(rotation_angle);
    painter.rect(
        Rect::from_xywh(-30.0, -30.0, 60.0, 60.0),
        &Paint { color: [1.0, 0.3, 0.3, 1.0], ..Default::default() },
    );
    painter.restore();
    painter.text("Rotating", Point::new(75.0, 425.0), 12.0,
        &Paint { color: [0.7, 0.7, 0.7, 1.0], ..Default::default() });

    // Scaling square
    let scale_factor = (time * 2.0).sin() * 0.3 + 1.0;
    painter.save();
    painter.translate(Offset::new(220.0, 360.0));
    painter.scale(scale_factor, scale_factor);
    painter.rect(
        Rect::from_xywh(-25.0, -25.0, 50.0, 50.0),
        &Paint { color: [0.3, 1.0, 0.3, 1.0], ..Default::default() },
    );
    painter.restore();
    painter.text("Scaling", Point::new(195.0, 425.0), 12.0,
        &Paint { color: [0.7, 0.7, 0.7, 1.0], ..Default::default() });

    // Combined: rotate + scale
    painter.save();
    painter.translate(Offset::new(340.0, 360.0));
    painter.rotate(rotation_angle * 0.7);
    painter.scale(1.2, 1.2);
    painter.rect(
        Rect::from_xywh(-30.0, -30.0, 60.0, 60.0),
        &Paint { color: [0.3, 0.3, 1.0, 1.0], ..Default::default() },
    );
    painter.restore();
    painter.text("Combined", Point::new(310.0, 425.0), 12.0,
        &Paint { color: [0.7, 0.7, 0.7, 1.0], ..Default::default() });

    // Section 5: Opacity & Blending
    painter.text(
        "5. OPACITY & BLENDING",
        Point::new(30.0, 390.0),
        24.0,
        &Paint { color: [1.0, 1.0, 0.0, 1.0], ..Default::default() },
    );

    // Different opacity levels
    for i in 0..5 {
        let opacity = (i + 1) as f32 * 0.2;
        painter.save();
        painter.set_opacity(opacity);
        painter.rect(
            Rect::from_xywh(30.0 + i as f32 * 80.0, 425.0, 70.0, 60.0),
            &Paint { color: [0.0, 0.8, 1.0, 1.0], ..Default::default() },
        );
        painter.restore();

        painter.text(
            &format!("{:.0}%", opacity * 100.0),
            Point::new(40.0 + i as f32 * 80.0, 495.0),
            12.0,
            &Paint { color: [0.7, 0.7, 0.7, 1.0], ..Default::default() },
        );
    }

    // Section 6: Borders & Strokes
    painter.text(
        "6. BORDERS & STROKES",
        Point::new(30.0, 540.0),
        24.0,
        &Paint { color: [1.0, 1.0, 0.0, 1.0], ..Default::default() },
    );

    // Various stroke widths
    for i in 0..4 {
        let width = (i + 1) as f32 * 2.0;
        painter.rect(
            Rect::from_xywh(30.0 + i as f32 * 120.0, 575.0, 100.0, 80.0),
            &Paint {
                color: [0.5, 0.8, 0.3, 1.0],
                stroke_width: width,
                ..Default::default()
            },
        );
        painter.text(
            &format!("{}px", width),
            Point::new(50.0 + i as f32 * 120.0, 665.0),
            12.0,
            &Paint { color: [0.7, 0.7, 0.7, 1.0], ..Default::default() },
        );
    }

    // Rounded rectangles
    painter.text("Rounded Corners:", Point::new(30.0, 705.0), 16.0,
        &Paint { color: [0.8, 0.8, 0.8, 1.0], ..Default::default() });

    for i in 0..4 {
        let radius = i as f32 * 5.0;
        painter.rrect(
            RRect {
                rect: Rect::from_xywh(30.0 + i as f32 * 120.0, 730.0, 100.0, 80.0),
                corner_radius: radius,
            },
            &Paint { color: [0.8, 0.3, 0.9, 1.0], ..Default::default() },
        );
        painter.text(
            &format!("r={}", radius),
            Point::new(50.0 + i as f32 * 120.0, 820.0),
            12.0,
            &Paint { color: [0.7, 0.7, 0.7, 1.0], ..Default::default() },
        );
    }
}

/// Helper: Draw text with shadow
fn draw_text_with_shadow(
    painter: &mut EguiPainter,
    text: &str,
    position: Point,
    font_size: f32,
    color: [f32; 4],
) {
    // Shadow
    painter.text(
        text,
        Point::new(position.x + 2.0, position.y + 2.0),
        font_size,
        &Paint { color: [0.0, 0.0, 0.0, 0.5], ..Default::default() },
    );

    // Main text
    painter.text(text, position, font_size, &Paint { color, ..Default::default() });
}

/// Helper: Draw rect with shadow
fn draw_rect_with_shadow(
    painter: &mut EguiPainter,
    rect: Rect,
    color: [f32; 4],
    offset_x: f32,
    offset_y: f32,
) {
    // Shadow layers
    for i in 0..8 {
        let progress = i as f32 / 7.0;
        let blur = progress * 6.0;
        let opacity = 0.08 * (1.0 - progress);

        painter.save();
        painter.set_opacity(opacity);
        painter.rect(
            Rect::from_xywh(
                rect.left() + offset_x + blur * 0.5,
                rect.top() + offset_y + blur * 0.5,
                rect.width() + blur * 2.0,
                rect.height() + blur * 2.0,
            ),
            &Paint { color: [0.0, 0.0, 0.0, 1.0], ..Default::default() },
        );
        painter.restore();
    }

    // Main shape
    painter.rect(rect, &Paint { color, ..Default::default() });
}

/// Helper: Draw circle with glow (simplified)
fn draw_circle_with_glow(painter: &mut EguiPainter, center: Point, radius: f32, color: [f32; 4]) {
    // Simplified glow - concentric circles with decreasing opacity
    for i in (0..20).rev() {
        let t = i as f32 / 19.0;
        let falloff = 1.0 - t;
        let eased = falloff * falloff * falloff;
        let current_radius = radius + (1.0 - eased) * 30.0;
        let current_color = [color[0], color[1], color[2], color[3] * eased * 0.3];

        painter.circle(center, current_radius, &Paint { color: current_color, ..Default::default() });
    }

    // Solid core
    painter.circle(center, radius, &Paint { color, ..Default::default() });
}

/// Helper: Draw horizontal gradient (simulated)
fn draw_horizontal_gradient(
    painter: &mut EguiPainter,
    rect: Rect,
    start_color: [f32; 4],
    end_color: [f32; 4],
    steps: usize,
) {
    let step_width = rect.width() / steps as f32;

    for i in 0..steps {
        let t = i as f32 / (steps - 1) as f32;
        let color = [
            start_color[0] * (1.0 - t) + end_color[0] * t,
            start_color[1] * (1.0 - t) + end_color[1] * t,
            start_color[2] * (1.0 - t) + end_color[2] * t,
            start_color[3] * (1.0 - t) + end_color[3] * t,
        ];

        painter.rect(
            Rect::from_xywh(
                rect.left() + i as f32 * step_width,
                rect.top(),
                step_width + 1.0,
                rect.height(),
            ),
            &Paint { color, ..Default::default() },
        );
    }
}

/// Helper: Draw vertical gradient (simulated)
fn draw_vertical_gradient(
    painter: &mut EguiPainter,
    rect: Rect,
    start_color: [f32; 4],
    end_color: [f32; 4],
    steps: usize,
) {
    let step_height = rect.height() / steps as f32;

    for i in 0..steps {
        let t = i as f32 / (steps - 1) as f32;
        let color = [
            start_color[0] * (1.0 - t) + end_color[0] * t,
            start_color[1] * (1.0 - t) + end_color[1] * t,
            start_color[2] * (1.0 - t) + end_color[2] * t,
            start_color[3] * (1.0 - t) + end_color[3] * t,
        ];

        painter.rect(
            Rect::from_xywh(
                rect.left(),
                rect.top() + i as f32 * step_height,
                rect.width(),
                step_height + 1.0,
            ),
            &Paint { color, ..Default::default() },
        );
    }
}
