# FLUI Widget Derive Macros - Clean API Design

## 🎯 Vision: One-Line Widget Declaration

Instead of:
```rust
// ❌ OLD: 3 steps, easy to forget
impl StatefulWidget for Counter {
    type State = CounterState;
    fn create_state(&self) -> Self::State { ... }
}
impl Widget for Counter {}
impl DynWidget for Counter {}
```

We want:
```rust
// ✅ NEW: One derive!
#[derive(StatefulWidget)]
struct Counter {
    initial: i32,
}

impl State for CounterState {
    fn build(&self, cx: &BuildContext) -> BoxedWidget { ... }
}
```

---

## 📐 Complete API Design

### **1. StatelessWidget**

```rust
use flui::prelude::*;

#[derive(StatelessWidget)]
struct Text {
    text: String,
    font_size: f32,
}

impl StatelessWidget for Text {
    fn build(&self, cx: &BuildContext) -> BoxedWidget {
        // Build widget tree
        Box::new(RenderText {
            text: self.text.clone(),
            font_size: self.font_size,
        })
    }
}

// ✅ Auto-generated by derive:
// impl Widget for Text { }
// impl DynWidget for Text { }
// impl Clone for Text { }
```

### **2. StatefulWidget**

```rust
use flui::prelude::*;

#[derive(StatefulWidget)]
struct Counter {
    initial: i32,
}

impl StatefulWidget for Counter {
    type State = CounterState;

    fn create_state(&self) -> Self::State {
        CounterState { count: self.initial }
    }
}

// State is separate struct
#[derive(State)]
struct CounterState {
    count: i32,
}

impl State for CounterState {
    fn build(&self, cx: &BuildContext) -> BoxedWidget {
        Row::new()
            .child(Button::new("-").on_press(|| self.decrement()))
            .child(Text::new(format!("{}", self.count)))
            .child(Button::new("+").on_press(|| self.increment()))
            .boxed()
    }
}

impl CounterState {
    fn increment(&mut self) {
        self.count += 1;
    }

    fn decrement(&mut self) {
        self.count -= 1;
    }
}

// ✅ Auto-generated by derive:
// impl Widget for Counter { }
// impl DynWidget for Counter { }
// impl Clone for Counter { }
```

### **3. InheritedWidget**

```rust
use flui::prelude::*;

#[derive(InheritedWidget)]
struct Theme {
    primary_color: Color,
    font_size: f32,
    child: BoxedWidget,
}

impl InheritedWidget for Theme {
    fn update_should_notify(&self, old: &Self) -> bool {
        self.primary_color != old.primary_color ||
        self.font_size != old.font_size
    }
}

// Usage:
let theme = Theme {
    primary_color: Color::BLUE,
    font_size: 16.0,
    child: MyApp::new().boxed(),
};

// Later, access in descendants:
let theme = cx.depend_on::<Theme>();
let color = theme.primary_color;

// ✅ Auto-generated by derive:
// impl Widget for Theme { }
// impl DynWidget for Theme { }
// impl Clone for Theme { }
```

### **4. RenderObjectWidget**

```rust
use flui::prelude::*;

#[derive(RenderObjectWidget)]
#[render_object(arity = "single")]
struct Opacity {
    opacity: f32,
    child: BoxedWidget,
}

impl RenderObjectWidget for Opacity {
    type Arity = SingleArity;
    type Render = RenderOpacity;

    fn create_render_object(&self) -> Self::Render {
        RenderOpacity {
            opacity: self.opacity,
        }
    }

    fn update_render_object(&self, render: &mut Self::Render) {
        render.opacity = self.opacity;
    }
}

// RenderObject implementation
#[derive(Debug)]
struct RenderOpacity {
    opacity: f32,
}

impl RenderObject for RenderOpacity {
    type Arity = SingleArity;

    fn layout(&mut self, cx: &mut LayoutCx<Self::Arity>) -> Size {
        let child = cx.child();
        cx.layout_child(child, cx.constraints())
    }

    fn paint(&self, cx: &PaintCx<Self::Arity>) -> BoxedLayer {
        let child_layer = cx.capture_child_layer(cx.child());
        Box::new(OpacityLayer::new(child_layer, self.opacity))
    }
}

// ✅ Auto-generated by derive:
// impl Widget for Opacity { }
// impl DynWidget for Opacity { }
// impl Clone for Opacity { }
```

---

## 🔧 Derive Macro Implementation

### **Macro Crate Structure**

```
crates/
├── flui_macros/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── stateless.rs     // #[derive(StatelessWidget)]
│       ├── stateful.rs      // #[derive(StatefulWidget)]
│       ├── inherited.rs     // #[derive(InheritedWidget)]
│       ├── render_object.rs // #[derive(RenderObjectWidget)]
│       └── utils.rs         // Common utilities
```

### **flui_macros/Cargo.toml**

```toml
[package]
name = "flui_macros"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full", "extra-traits"] }
quote = "1.0"
proc-macro2 = "1.0"
darling = "0.20"  # For parsing attributes
```

### **flui_macros/src/lib.rs**

```rust
use proc_macro::TokenStream;

mod stateless;
mod stateful;
mod inherited;
mod render_object;
mod utils;

/// Derive macro for StatelessWidget
///
/// # Example
/// ```rust
/// #[derive(StatelessWidget)]
/// struct Text {
///     text: String,
/// }
///
/// impl StatelessWidget for Text {
///     fn build(&self, cx: &BuildContext) -> BoxedWidget {
///         // ...
///     }
/// }
/// ```
#[proc_macro_derive(StatelessWidget)]
pub fn derive_stateless_widget(input: TokenStream) -> TokenStream {
    stateless::derive(input)
}

/// Derive macro for StatefulWidget
///
/// # Example
/// ```rust
/// #[derive(StatefulWidget)]
/// struct Counter {
///     initial: i32,
/// }
///
/// impl StatefulWidget for Counter {
///     type State = CounterState;
///     fn create_state(&self) -> Self::State { ... }
/// }
/// ```
#[proc_macro_derive(StatefulWidget)]
pub fn derive_stateful_widget(input: TokenStream) -> TokenStream {
    stateful::derive(input)
}

/// Derive macro for InheritedWidget
///
/// # Example
/// ```rust
/// #[derive(InheritedWidget)]
/// struct Theme {
///     primary_color: Color,
///     child: BoxedWidget,
/// }
/// ```
#[proc_macro_derive(InheritedWidget)]
pub fn derive_inherited_widget(input: TokenStream) -> TokenStream {
    inherited::derive(input)
}

/// Derive macro for RenderObjectWidget
///
/// # Example
/// ```rust
/// #[derive(RenderObjectWidget)]
/// #[render_object(arity = "single")]
/// struct Opacity {
///     opacity: f32,
///     child: BoxedWidget,
/// }
/// ```
#[proc_macro_derive(RenderObjectWidget, attributes(render_object))]
pub fn derive_render_object_widget(input: TokenStream) -> TokenStream {
    render_object::derive(input)
}

/// Derive macro for State
///
/// # Example
/// ```rust
/// #[derive(State)]
/// struct CounterState {
///     count: i32,
/// }
/// ```
#[proc_macro_derive(State)]
pub fn derive_state(input: TokenStream) -> TokenStream {
    stateful::derive_state(input)
}
```

### **flui_macros/src/stateless.rs**

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let expanded = quote! {
        // Auto-implement Widget
        impl #impl_generics ::flui_core::Widget for #name #ty_generics #where_clause {
            fn key(&self) -> ::std::option::Option<&str> {
                ::std::option::Option::None
            }
        }

        // Auto-implement DynWidget
        impl #impl_generics ::flui_core::DynWidget for #name #ty_generics #where_clause {
            fn as_any(&self) -> &dyn ::std::any::Any {
                self
            }

            fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
                self
            }
        }

        // Auto-implement Clone if all fields are Clone
        // (This is optional - user can also derive Clone manually)
    };

    TokenStream::from(expanded)
}
```

### **flui_macros/src/stateful.rs**

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let expanded = quote! {
        // Auto-implement Widget
        impl #impl_generics ::flui_core::Widget for #name #ty_generics #where_clause {
            fn key(&self) -> ::std::option::Option<&str> {
                ::std::option::Option::None
            }
        }

        // Auto-implement DynWidget
        impl #impl_generics ::flui_core::DynWidget for #name #ty_generics #where_clause {
            fn as_any(&self) -> &dyn ::std::any::Any {
                self
            }

            fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
                self
            }
        }
    };

    TokenStream::from(expanded)
}

pub fn derive_state(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let expanded = quote! {
        // State is already a trait, just ensure required bounds
        // Users must implement State trait manually
    };

    TokenStream::from(expanded)
}
```

### **flui_macros/src/render_object.rs**

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Attribute};
use darling::FromDeriveInput;

#[derive(FromDeriveInput)]
#[darling(attributes(render_object))]
struct RenderObjectArgs {
    arity: Option<String>,
}

pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    // Parse attributes
    let args = RenderObjectArgs::from_derive_input(&input).unwrap();

    let expanded = quote! {
        // Auto-implement Widget
        impl #impl_generics ::flui_core::Widget for #name #ty_generics #where_clause {
            fn key(&self) -> ::std::option::Option<&str> {
                ::std::option::Option::None
            }
        }

        // Auto-implement DynWidget
        impl #impl_generics ::flui_core::DynWidget for #name #ty_generics #where_clause {
            fn as_any(&self) -> &dyn ::std::any::Any {
                self
            }

            fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
                self
            }
        }

        // Note: User must still implement RenderObjectWidget trait manually
        // because we need associated types (Render, Arity)
    };

    TokenStream::from(expanded)
}
```

---

## 🎯 Usage Examples

### **Complete Counter Example**

```rust
use flui::prelude::*;

// Widget declaration - ONE derive!
#[derive(StatefulWidget, Clone)]
struct Counter {
    initial: i32,
}

impl StatefulWidget for Counter {
    type State = CounterState;

    fn create_state(&self) -> Self::State {
        CounterState { count: self.initial }
    }
}

// State declaration
#[derive(State)]
struct CounterState {
    count: i32,
}

impl State for CounterState {
    fn build(&self, cx: &BuildContext) -> BoxedWidget {
        Column::new()
            .child(Text::new(format!("Count: {}", self.count)))
            .child(
                Row::new()
                    .child(Button::new("-").on_press(|| self.decrement()))
                    .child(Button::new("+").on_press(|| self.increment()))
            )
            .boxed()
    }
}

impl CounterState {
    fn increment(&mut self) {
        self.count += 1;
    }

    fn decrement(&mut self) {
        self.count -= 1;
    }
}

// Usage
fn main() {
    let app = Counter { initial: 0 };
    // Widget, DynWidget auto-implemented!
}
```

### **Theme Provider Example**

```rust
use flui::prelude::*;

#[derive(InheritedWidget, Clone)]
struct AppTheme {
    primary_color: Color,
    secondary_color: Color,
    font_size: f32,
    child: BoxedWidget,
}

impl InheritedWidget for AppTheme {
    fn update_should_notify(&self, old: &Self) -> bool {
        self.primary_color != old.primary_color ||
        self.secondary_color != old.secondary_color ||
        self.font_size != old.font_size
    }
}

// Usage
let app = AppTheme {
    primary_color: Color::BLUE,
    secondary_color: Color::GREEN,
    font_size: 16.0,
    child: MyApp::new().boxed(),
};
```

---

## 📊 Comparison: Before vs After

```rust
// ============================================
// BEFORE: Current macro approach
// ============================================

impl StatefulWidget for Counter {
    type State = CounterState;
    fn create_state(&self) -> Self::State { ... }
}

impl_widget_for_stateful!(Counter);  // ❌ Easy to forget!

// ============================================
// AFTER: Derive macro
// ============================================

#[derive(StatefulWidget)]  // ✅ ONE line!
struct Counter {
    initial: i32,
}

impl StatefulWidget for Counter {
    type State = CounterState;
    fn create_state(&self) -> Self::State { ... }
}

// Widget + DynWidget auto-implemented! ✅
```

---

## ✅ Benefits

### **1. Zero Friction**
- One `#[derive(...)]` line
- No manual macro calls
- Hard to forget

### **2. Compile-Time Safety**
- Can't forget to implement Widget
- Can't forget to implement DynWidget
- Derive ensures all required traits

### **3. Clear Intent**
```rust
#[derive(StatelessWidget)]  // ← Clear: this is stateless
#[derive(StatefulWidget)]   // ← Clear: this is stateful
#[derive(InheritedWidget)]  // ← Clear: this provides data
```

### **4. IDE Support**
- Rust-analyzer shows all derived impls
- Autocomplete works perfectly
- Go-to-definition works

### **5. Consistent API**
- All widgets use same pattern
- Easy to learn
- Easy to teach

---

## 🚀 Migration Path

### **Step 1: Add flui_macros crate**
```bash
cd crates
cargo new flui_macros --lib
```

### **Step 2: Implement derive macros**
- Start with StatelessWidget (simplest)
- Then StatefulWidget
- Then InheritedWidget
- Finally RenderObjectWidget

### **Step 3: Deprecate old macros**
```rust
#[deprecated(note = "Use #[derive(StatefulWidget)] instead")]
macro_rules! impl_widget_for_stateful {
    // ...
}
```

### **Step 4: Update examples**
- Update all examples to use derive
- Add migration guide
- Update documentation

---

## 🎯 Next Steps

1. Create `flui_macros` crate
2. Implement `StatelessWidget` derive (simplest)
3. Test with existing widgets
4. Implement remaining derives
5. Update flui_core to re-export macros

Ready to implement?
