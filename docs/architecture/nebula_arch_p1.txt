# Nebula Framework - Complete Architecture Documentation
## Part 1: Core Structure & Foundation Layer

> Flutter-inspired declarative UI framework built on egui  
> Version: 0.1.0 | Architecture: Three-Tree Pattern

---

## 📁 Project Structure

```
nebula/
├── Cargo.toml
├── README.md
├── ARCHITECTURE.md
│
├── crates/
│   ├── nebula_core/              # Core traits & types
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── widget.rs          # Widget trait
│   │       ├── element.rs         # Element trait & tree
│   │       ├── render_object.rs   # RenderObject trait
│   │       └── build_context.rs   # BuildContext
│   │
│   ├── nebula_foundation/        # Foundation layer (Flutter's foundation)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── key.rs            # Key system
│   │       ├── diagnostics.rs    # Debug utilities
│   │       ├── change_notifier.rs
│   │       ├── listenable.rs
│   │       ├── observer_list.rs
│   │       ├── platform.rs
│   │       ├── assertions.rs
│   │       ├── collections.rs
│   │       └── constants.rs
│   │
│   ├── nebula_widgets/           # Widget implementations
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── framework/
│   │       │   ├── mod.rs
│   │       │   ├── stateful.rs
│   │       │   ├── stateless.rs
│   │       │   └── inherited.rs
│   │       ├── basic/
│   │       │   ├── mod.rs
│   │       │   ├── container.rs
│   │       │   ├── sized_box.rs
│   │       │   ├── padding.rs
│   │       │   ├── center.rs
│   │       │   └── align.rs
│   │       ├── layout/
│   │       │   ├── mod.rs
│   │       │   ├── flex.rs        # Row, Column
│   │       │   ├── stack.rs
│   │       │   ├── wrap.rs
│   │       │   └── custom.rs
│   │       ├── text/
│   │       │   ├── mod.rs
│   │       │   ├── text.rs
│   │       │   └── rich_text.rs
│   │       ├── input/
│   │       │   ├── mod.rs
│   │       │   ├── button.rs
│   │       │   ├── text_field.rs
│   │       │   └── checkbox.rs
│   │       └── scrolling/
│   │           ├── mod.rs
│   │           ├── scroll_view.rs
│   │           └── list_view.rs
│   │
│   ├── nebula_rendering/         # Rendering layer
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── object.rs         # RenderObject impl
│   │       ├── box_protocol.rs   # BoxConstraints
│   │       ├── flex.rs           # Flex layout
│   │       ├── stack.rs          # Stack layout
│   │       └── proxy_box.rs      # RenderProxyBox
│   │
│   ├── nebula_painting/          # Painting utilities
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── decoration.rs
│   │       ├── edge_insets.rs
│   │       ├── alignment.rs
│   │       ├── borders.rs
│   │       └── text_style.rs
│   │
│   ├── nebula_animation/         # Animation system
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── controller.rs
│   │       ├── tween.rs
│   │       ├── curves.rs
│   │       └── transitions.rs
│   │
│   ├── nebula_gestures/          # Gesture detection
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── recognizer.rs
│   │       ├── detector.rs
│   │       └── events.rs
│   │
│   ├── nebula_scheduler/         # Frame scheduling
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── binding.rs
│   │       ├── ticker.rs
│   │       └── priority.rs
│   │
│   └── nebula_platform/          # Platform integration
│       ├── Cargo.toml
│       └── src/
│           ├── lib.rs
│           ├── app.rs            # NebulaApp
│           ├── window.rs
│           └── services.rs
│
├── nebula/                       # Main crate (re-exports)
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       └── prelude.rs
│
├── examples/
│   ├── counter.rs
│   ├── layout_demo.rs
│   ├── animation_demo.rs
│   └── node_editor.rs
│
└── benches/
    └── widget_bench.rs
```

---

## 🏗️ Three-Tree Architecture

### Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    Widget Tree                          │
│              (Immutable Configuration)                  │
│                                                         │
│  MyApp                                                  │
│    └─ Container                                         │
│         └─ Column                                       │
│              ├─ Text("Hello")                          │
│              └─ Button("Click")                        │
└─────────────────────────────────────────────────────────┘
                         ↓ createElement()
┌─────────────────────────────────────────────────────────┐
│                   Element Tree                          │
│                 (Mutable State Holder)                  │
│                                                         │
│  ComponentElement<MyApp>                                │
│    └─ SingleChildElement<Container>                     │
│         └─ MultiChildElement<Column>                    │
│              ├─ LeafElement<Text>                      │
│              └─ LeafElement<Button>                    │
└─────────────────────────────────────────────────────────┘
                         ↓ createRenderObject()
┌─────────────────────────────────────────────────────────┐
│                   Render Tree                           │
│                (Layout & Paint Logic)                   │
│                                                         │
│  RenderView                                             │
│    └─ RenderConstrainedBox                              │
│         └─ RenderFlex                                   │
│              ├─ RenderParagraph                        │
│              └─ RenderPointerListener                  │
└─────────────────────────────────────────────────────────┘
                         ↓ paint()
┌─────────────────────────────────────────────────────────┐
│                 egui::Painter                           │
│              (Immediate Mode Rendering)                 │
└─────────────────────────────────────────────────────────┘
```

---

## 🎯 Foundation Layer (nebula_foundation)

### Key System (`key.rs`)

```rust
// Core Key trait
pub trait Key: Any + Debug + Send + Sync {
    fn equals(&self, other: &dyn Key) -> bool;
    fn hash_code(&self) -> u64;
    fn as_any(&self) -> &dyn Any;
}

// LocalKey - scoped to parent
pub trait LocalKey: Key {}

// ValueKey<T> - identified by value
#[derive(Debug, Clone)]
pub struct ValueKey<T: Hash + Eq + Clone + Send + Sync + 'static> {
    value: T,
}

// UniqueKey - always unique
pub struct UniqueKey {
    id: u64, // Generated atomically
}

// ObjectKey - identified by pointer
pub struct ObjectKey<T: 'static> {
    ptr: *const T,
}

// GlobalKey<T> - can access state from anywhere
pub struct GlobalKey<T: 'static> {
    id: GlobalKeyId,
    _phantom: PhantomData<T>,
}

impl<T> GlobalKey<T> {
    pub fn current_state(&self) -> Option<&T>;
    pub fn current_context(&self) -> Option<BuildContext>;
}
```

**Usage:**
```rust
// In widget
let key = ValueKey::new("my-widget");
let global = GlobalKey::<CounterState>::new();

// Access from anywhere
if let Some(state) = global.current_state() {
    state.increment();
}
```

### Diagnostics (`diagnostics.rs`)

```rust
// Diagnosticable trait
pub trait Diagnosticable {
    fn to_string_short(&self) -> String;
    fn to_string_deep(&self) -> String;
    fn debug_fill_properties(&self, props: &mut DiagnosticPropertiesBuilder);
}

// DiagnosticsNode - debug info
pub enum DiagnosticsNode {
    StringProperty { name: String, value: String },
    IntProperty { name: String, value: i64 },
    FlagProperty { name: String, shown: bool },
}

// Builder for diagnostics
pub struct DiagnosticPropertiesBuilder {
    properties: Vec<DiagnosticsNode>,
}
```

### ChangeNotifier & Listenable (`change_notifier.rs`)

```rust
// Listenable - base observable trait
pub trait Listenable {
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId;
    fn remove_listener(&mut self, id: ListenerId);
    fn notify_listeners(&self);
}

// ChangeNotifier - simple observable
pub struct ChangeNotifier {
    listeners: ObserverList<VoidCallback>,
}

// ValueNotifier<T> - observable value
pub struct ValueNotifier<T: Clone> {
    value: T,
    notifier: ChangeNotifier,
}

impl<T: Clone> ValueNotifier<T> {
    pub fn new(value: T) -> Self;
    pub fn value(&self) -> &T;
    pub fn set_value(&mut self, value: T); // Auto-notifies
}

// ValueListenable<T> - read-only observable
pub trait ValueListenable<T>: Listenable {
    fn value(&self) -> &T;
}
```

### ObserverList (`observer_list.rs`)

```rust
// Optimized for small number of observers
pub struct ObserverList<T> {
    observers: Vec<(ListenerId, T)>,
}

// Optimized for large number of observers
pub struct HashedObserverList<T> {
    observers: HashMap<ListenerId, T>,
}

impl<T> ObserverList<T> {
    pub fn new() -> Self;
    pub fn add(&mut self, observer: T) -> ListenerId;
    pub fn remove(&mut self, id: ListenerId);
    pub fn is_empty(&self) -> bool;
    pub fn iter(&self) -> impl Iterator<Item = &T>;
}
```

### Platform Detection (`platform.rs`)

```rust
// Debug/Release mode
pub const K_DEBUG_MODE: bool = cfg!(debug_assertions);
pub const K_RELEASE_MODE: bool = !cfg!(debug_assertions);

// Platform
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TargetPlatform {
    Android, iOS, Linux, MacOS, Windows, Web,
}

pub fn default_target_platform() -> TargetPlatform {
    #[cfg(target_os = "windows")]
    return TargetPlatform::Windows;
    // ... other platforms
}

// Brightness
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Brightness { Light, Dark }
```

### Assertions & Errors (`assertions.rs`)

```rust
// FlutterError - structured error
#[derive(Debug)]
pub struct FlutterError {
    pub summary: ErrorSummary,
    pub description: Vec<ErrorDescription>,
    pub hints: Vec<ErrorHint>,
    pub stack_trace: Option<Backtrace>,
}

impl FlutterError {
    pub fn new(summary: impl Into<String>) -> Self;
    pub fn with_description(self, desc: impl Into<String>) -> Self;
    pub fn with_hint(self, hint: impl Into<String>) -> Self;
    pub fn report(self);
}

// Usage
FlutterError::new("Widget not found")
    .with_description("Counter widget was disposed")
    .with_hint("Check widget lifecycle")
    .report();
```

### Type Aliases (`lib.rs`)

```rust
// Callback types
pub type VoidCallback = Box<dyn Fn() + Send + Sync>;
pub type AsyncCallback = Box<dyn Fn() -> BoxFuture<'static, ()> + Send + Sync>;
pub type ValueChanged<T> = Box<dyn Fn(T) + Send + Sync>;
pub type ValueGetter<T> = Box<dyn Fn() -> T + Send + Sync>;
pub type ValueSetter<T> = Box<dyn Fn(T) + Send + Sync>;

// Common types
pub type ListenerId = u64;
```

---

## 📦 Dependencies (Cargo.toml)

### Main Workspace
```toml
[workspace]
members = [
    "crates/nebula_core",
    "crates/nebula_foundation",
    "crates/nebula_widgets",
    "crates/nebula_rendering",
    "crates/nebula_painting",
    "crates/nebula_animation",
    "crates/nebula_gestures",
    "crates/nebula_scheduler",
    "crates/nebula_platform",
    "nebula",
]
resolver = "2"

[workspace.dependencies]
egui = "0.29"
eframe = "0.29"
bon = "2.3"
```

### nebula_foundation/Cargo.toml
```toml
[package]
name = "nebula_foundation"
version = "0.1.0"
edition = "2021"

[dependencies]
# No dependencies - pure Rust
```

### nebula_core/Cargo.toml
```toml
[package]
name = "nebula_core"
version = "0.1.0"
edition = "2021"

[dependencies]
nebula_foundation = { path = "../nebula_foundation" }
```

---

## 🎨 Design Principles

### 1. Separation of Concerns
- **Widget**: Immutable configuration (what to show)
- **Element**: Mutable state holder (lifecycle management)
- **RenderObject**: Layout & paint (how to draw)

### 2. Performance Strategy
- Elements prevent unnecessary rebuilds
- Keys enable efficient list updates
- RenderObjects cache layout results
- egui handles actual rendering

### 3. Type Safety
- Strong typing prevents errors at compile time
- Trait objects for polymorphism
- Builder pattern for ergonomic APIs

### 4. Developer Experience
- Declarative API (Flutter-like)
- Hot-reload friendly (via keys)
- Comprehensive diagnostics
- Clear error messages

---

**Next:** Part 2 - Core Traits & Widget System
