# Nebula Framework - Complete Architecture Documentation
## Part 3: Widget Framework (nebula_widgets)

---

## ðŸ“¦ Framework Components

### StatelessWidget (`framework/stateless.rs`)

```rust
/// StatelessWidget - immutable widget
pub trait StatelessWidget: Widget {
    /// Build the widget tree
    fn build(&self, context: &BuildContext) -> Box<dyn Widget>;
}

// Element for StatelessWidget
pub struct ComponentElement {
    id: ElementId,
    widget: Box<dyn Widget>,
    child: Option<Box<dyn Element>>,
    parent: Option<ElementId>,
    dirty: bool,
}

impl ComponentElement {
    pub fn new(widget: Box<dyn Widget>) -> Self {
        Self {
            id: ElementId::new(),
            widget,
            child: None,
            parent: None,
            dirty: true,
        }
    }
}

impl Element for ComponentElement {
    fn mount(&mut self, parent: Option<ElementId>, _slot: usize) {
        self.parent = parent;
        self.rebuild();
    }
    
    fn rebuild(&mut self) {
        if !self.dirty { return; }
        self.dirty = false;
        
        // Build child widget
        let context = self.create_build_context();
        let stateless = self.widget.as_any()
            .downcast_ref::<dyn StatelessWidget>()
            .expect("Not a StatelessWidget");
        
        let new_child_widget = stateless.build(&context);
        
        // Update or create child element
        match &mut self.child {
            Some(old_child) => {
                if can_update(old_child.widget(), new_child_widget.as_ref()) {
                    old_child.update(new_child_widget);
                } else {
                    old_child.unmount();
                    let mut new_element = new_child_widget.create_element();
                    new_element.mount(Some(self.id), 0);
                    self.child = Some(new_element);
                }
            }
            None => {
                let mut element = new_child_widget.create_element();
                element.mount(Some(self.id), 0);
                self.child = Some(element);
            }
        }
    }
    
    fn update(&mut self, new_widget: Box<dyn Widget>) {
        self.widget = new_widget;
        self.mark_needs_build();
    }
    
    fn mark_needs_build(&mut self) {
        self.dirty = true;
    }
    
    // ... other Element methods
}
```

---

### StatefulWidget (`framework/stateful.rs`)

```rust
/// StatefulWidget - widget with mutable state
pub trait StatefulWidget: Widget {
    type State: State;
    
    /// Create state object
    fn create_state(&self) -> Self::State;
}

/// State - mutable state for StatefulWidget
pub trait State: Any {
    type Widget: StatefulWidget;
    
    /// Build widget tree
    fn build(&mut self, context: &BuildContext) -> Box<dyn Widget>;
    
    // === Lifecycle Callbacks ===
    
    /// Called when inserted into tree
    fn init_state(&mut self) {}
    
    /// Called when widget configuration changes
    fn did_update_widget(&mut self, old_widget: &Self::Widget) {}
    
    /// Called when InheritedWidget changes
    fn did_change_dependencies(&mut self) {}
    
    /// Called when moved in tree
    fn deactivate(&mut self) {}
    
    /// Called when permanently removed
    fn dispose(&mut self) {}
    
    // === State Management ===
    
    /// Request rebuild
    fn set_state<F>(&mut self, callback: F) 
    where 
        F: FnOnce(&mut Self),
    {
        callback(self);
        self.mark_needs_build();
    }
    
    /// Internal: mark dirty
    fn mark_needs_build(&mut self);
    
    /// Get current context
    fn context(&self) -> &BuildContext;
    
    /// Internal: set context
    fn set_context(&mut self, context: BuildContext);
}

// Element for StatefulWidget
pub struct StatefulElement {
    id: ElementId,
    widget: Box<dyn Widget>,
    state: Box<dyn Any>, // Actual State<T>
    child: Option<Box<dyn Element>>,
    parent: Option<ElementId>,
    dirty: bool,
    context: Option<BuildContext>,
}

impl StatefulElement {
    pub fn new<W: StatefulWidget + 'static>(widget: W) -> Self {
        let state = widget.create_state();
        
        Self {
            id: ElementId::new(),
            widget: Box::new(widget),
            state: Box::new(state),
            child: None,
            parent: None,
            dirty: true,
            context: None,
        }
    }
    
    fn state_mut<S: State + 'static>(&mut self) -> &mut S {
        self.state.downcast_mut::<S>()
            .expect("State type mismatch")
    }
}

impl Element for StatefulElement {
    fn mount(&mut self, parent: Option<ElementId>, _slot: usize) {
        self.parent = parent;
        
        // Create context
        let context = self.create_build_context();
        self.context = Some(context.clone());
        
        // Initialize state
        let state = self.state.downcast_mut::<dyn State>()
            .expect("Invalid state");
        state.set_context(context);
        state.init_state();
        
        self.rebuild();
    }
    
    fn rebuild(&mut self) {
        if !self.dirty { return; }
        self.dirty = false;
        
        let context = self.context.as_ref().unwrap();
        
        // Call build on state
        let state = self.state.downcast_mut::<dyn State>()
            .expect("Invalid state");
        let new_child_widget = state.build(context);
        
        // Update child
        match &mut self.child {
            Some(old_child) => {
                if can_update(old_child.widget(), new_child_widget.as_ref()) {
                    old_child.update(new_child_widget);
                } else {
                    old_child.unmount();
                    let mut new_element = new_child_widget.create_element();
                    new_element.mount(Some(self.id), 0);
                    self.child = Some(new_element);
                }
            }
            None => {
                let mut element = new_child_widget.create_element();
                element.mount(Some(self.id), 0);
                self.child = Some(element);
            }
        }
    }
    
    fn update(&mut self, new_widget: Box<dyn Widget>) {
        let old_widget = std::mem::replace(&mut self.widget, new_widget);
        
        // Notify state
        let state = self.state.downcast_mut::<dyn State>()
            .expect("Invalid state");
        state.did_update_widget(
            old_widget.as_any()
                .downcast_ref::<Self::Widget>()
                .unwrap()
        );
        
        self.mark_needs_build();
    }
    
    fn unmount(&mut self) {
        let state = self.state.downcast_mut::<dyn State>()
            .expect("Invalid state");
        state.dispose();
        
        if let Some(child) = &mut self.child {
            child.unmount();
        }
    }
    
    // ... other methods
}
```

**Example Usage:**
```rust
struct Counter {
    key: Option<Box<dyn Key>>,
}

impl StatefulWidget for Counter {
    type State = CounterState;
    
    fn create_state(&self) -> Self::State {
        CounterState {
            count: 0,
            context: None,
        }
    }
}

struct CounterState {
    count: i32,
    context: Option<BuildContext>,
}

impl State for CounterState {
    type Widget = Counter;
    
    fn build(&mut self, context: &BuildContext) -> Box<dyn Widget> {
        Column::new()
            .children(vec![
                Text::new(format!("Count: {}", self.count)).into_widget(),
                Button::new("Increment")
                    .on_pressed(|| {
                        self.set_state(|s| s.count += 1);
                    })
                    .into_widget(),
            ])
            .into_widget()
    }
    
    fn mark_needs_build(&mut self) {
        if let Some(ctx) = &self.context {
            ctx.mark_dirty();
        }
    }
    
    fn context(&self) -> &BuildContext {
        self.context.as_ref().unwrap()
    }
    
    fn set_context(&mut self, context: BuildContext) {
        self.context = Some(context);
    }
}
```

---

### InheritedWidget (`framework/inherited.rs`)

```rust
/// InheritedWidget - provide data down the tree
pub trait InheritedWidget: Widget {
    /// Should notify dependents on update?
    fn update_should_notify(&self, old: &Self) -> bool;
    
    /// Get the data to provide
    fn data(&self) -> &dyn Any;
}

// Element for InheritedWidget
pub struct InheritedElement {
    id: ElementId,
    widget: Box<dyn InheritedWidget>,
    child: Option<Box<dyn Element>>,
    dependents: HashSet<ElementId>,
}

impl InheritedElement {
    pub fn new(widget: Box<dyn InheritedWidget>) -> Self {
        Self {
            id: ElementId::new(),
            widget,
            child: None,
            dependents: HashSet::new(),
        }
    }
    
    pub fn register_dependent(&mut self, dependent: ElementId) {
        self.dependents.insert(dependent);
    }
    
    pub fn unregister_dependent(&mut self, dependent: ElementId) {
        self.dependents.remove(&dependent);
    }
}

impl Element for InheritedElement {
    fn update(&mut self, new_widget: Box<dyn Widget>) {
        let old_widget = std::mem::replace(
            &mut self.widget, 
            new_widget.as_any()
                .downcast::<Box<dyn InheritedWidget>>()
                .unwrap()
        );
        
        // Check if should notify
        if self.widget.update_should_notify(&*old_widget) {
            // Notify all dependents
            for dependent_id in &self.dependents {
                // Mark dependent as dirty
                // context.mark_dirty(*dependent_id);
            }
        }
    }
    
    // ... other methods
}

// BuildContext extension
impl BuildContext {
    pub fn depend_on_inherited<T: InheritedWidget + 'static>(
        &self
    ) -> Option<Arc<T>> {
        // Walk up tree to find InheritedWidget<T>
        // Register this element as dependent
        unimplemented!()
    }
}
```

**Example - Theme Provider:**
```rust
#[derive(Clone)]
struct ThemeProvider {
    theme: Theme,
    child: Box<dyn Widget>,
}

impl InheritedWidget for ThemeProvider {
    fn update_should_notify(&self, old: &Self) -> bool {
        self.theme != old.theme
    }
    
    fn data(&self) -> &dyn Any {
        &self.theme
    }
}

// Usage
fn my_widget_build(ctx: &BuildContext) -> Box<dyn Widget> {
    let theme = ctx.depend_on_inherited::<ThemeProvider>()
        .map(|p| p.theme.clone())
        .unwrap_or_default();
    
    Container::new()
        .color(theme.background)
        .into_widget()
}
```

---

## ðŸŽ¨ Basic Widgets

### Container (`basic/container.rs`)

```rust
#[derive(Debug, Clone)]
pub struct Container {
    pub key: Option<Box<dyn Key>>,
    pub width: Option<f32>,
    pub height: Option<f32>,
    pub padding: Option<EdgeInsets>,
    pub margin: Option<EdgeInsets>,
    pub color: Option<Color>,
    pub decoration: Option<BoxDecoration>,
    pub alignment: Option<Alignment>,
    pub child: Option<Box<dyn Widget>>,
}

impl Container {
    pub fn new() -> Self {
        Self {
            key: None,
            width: None,
            height: None,
            padding: None,
            margin: None,
            color: None,
            decoration: None,
            alignment: None,
            child: None,
        }
    }
    
    pub fn width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }
    
    pub fn height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }
    
    pub fn color(mut self, color: Color) -> Self {
        self.color = Some(color);
        self
    }
    
    pub fn child(mut self, child: impl IntoWidget) -> Self {
        self.child = Some(child.into_widget());
        self
    }
}

impl Widget for Container {
    fn create_element(&self) -> Box<dyn Element> {
        Box::new(SingleChildRenderObjectElement::new(self.clone()))
    }
}

// RenderObject for Container
struct RenderContainer {
    size: Size,
    constraints: BoxConstraints,
    width: Option<f32>,
    height: Option<f32>,
    padding: Option<EdgeInsets>,
    decoration: Option<BoxDecoration>,
    child: Option<Box<dyn RenderObject>>,
}

impl RenderObject for RenderContainer {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        self.constraints = constraints;
        
        // Calculate size
        let width = self.width.unwrap_or(constraints.max_width);
        let height = self.height.unwrap_or(constraints.max_height);
        
        let size = constraints.constrain(Size::new(width, height));
        
        // Layout child with padding
        if let Some(child) = &mut self.child {
            let child_constraints = if let Some(padding) = self.padding {
                BoxConstraints::tight(Size::new(
                    size.width - padding.horizontal(),
                    size.height - padding.vertical(),
                ))
            } else {
                BoxConstraints::tight(size)
            };
            
            child.layout(child_constraints);
        }
        
        self.size = size;
        size
    }
    
    fn paint(&self, painter: &egui::Painter, offset: Offset) {
        let rect = egui::Rect::from_min_size(
            egui::pos2(offset.x, offset.y),
            egui::vec2(self.size.width, self.size.height),
        );
        
        // Paint decoration
        if let Some(decoration) = &self.decoration {
            decoration.paint(painter, rect);
        }
        
        // Paint child
        if let Some(child) = &self.child {
            let child_offset = if let Some(padding) = self.padding {
                Offset::new(
                    offset.x + padding.left,
                    offset.y + padding.top,
                )
            } else {
                offset
            };
            
            child.paint(painter, child_offset);
        }
    }
    
    fn size(&self) -> Size {
        self.size
    }
    
    // ... other methods
}
```

---

### Flex Layout (Row/Column) (`layout/flex.rs`)

```rust
#[derive(Debug, Clone)]
pub struct Column {
    pub key: Option<Box<dyn Key>>,
    pub main_axis_alignment: MainAxisAlignment,
    pub cross_axis_alignment: CrossAxisAlignment,
    pub main_axis_size: MainAxisSize,
    pub children: Vec<Box<dyn Widget>>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MainAxisAlignment {
    Start,
    End,
    Center,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CrossAxisAlignment {
    Start,
    End,
    Center,
    Stretch,
    Baseline,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MainAxisSize {
    Min,
    Max,
}

impl Column {
    pub fn new() -> Self {
        Self {
            key: None,
            main_axis_alignment: MainAxisAlignment::Start,
            cross_axis_alignment: CrossAxisAlignment::Center,
            main_axis_size: MainAxisSize::Max,
            children: Vec::new(),
        }
    }
    
    pub fn children(mut self, children: Vec<Box<dyn Widget>>) -> Self {
        self.children = children;
        self
    }
}

// RenderFlex - implements flex layout algorithm
struct RenderFlex {
    direction: Axis,
    main_axis_alignment: MainAxisAlignment,
    cross_axis_alignment: CrossAxisAlignment,
    size: Size,
    children: Vec<Box<dyn RenderObject>>,
}

impl RenderObject for RenderFlex {
    fn layout(&mut self, constraints: BoxConstraints) -> Size {
        // Flutter's flex layout algorithm
        let mut total_flex = 0.0;
        let mut allocated_size = 0.0;
        let mut max_cross_size = 0.0;
        
        // 1. Layout inflexible children
        for child in &mut self.children {
            if !child.is_flexible() {
                let child_size = child.layout(constraints.loosen());
                
                allocated_size += match self.direction {
                    Axis::Vertical => child_size.height,
                    Axis::Horizontal => child_size.width,
                };
                
                let cross = match self.direction {
                    Axis::Vertical => child_size.width,
                    Axis::Horizontal => child_size.height,
                };
                max_cross_size = max_cross_size.max(cross);
            } else {
                total_flex += child.flex_factor();
            }
        }
        
        // 2. Distribute space to flexible children
        let free_space = constraints.max_main_axis(self.direction) - allocated_size;
        let space_per_flex = if total_flex > 0.0 {
            (free_space / total_flex).max(0.0)
        } else {
            0.0
        };
        
        for child in &mut self.children {
            if child.is_flexible() {
                let flex = child.flex_factor();
                let child_constraints = constraints.tighten_main_axis(
                    space_per_flex * flex,
                    self.direction,
                );
                let child_size = child.layout(child_constraints);
                
                let cross = match self.direction {
                    Axis::Vertical => child_size.width,
                    Axis::Horizontal => child_size.height,
                };
                max_cross_size = max_cross_size.max(cross);
            }
        }
        
        // 3. Calculate final size
        let main_size = allocated_size + (space_per_flex * total_flex);
        
        self.size = match self.direction {
            Axis::Vertical => Size::new(max_cross_size, main_size),
            Axis::Horizontal => Size::new(main_size, max_cross_size),
        };
        
        constraints.constrain(self.size)
    }
    
    fn paint(&self, painter: &egui::Painter, offset: Offset) {
        let mut current_offset = offset;
        
        for child in &self.children {
            child.paint(painter, current_offset);
            
            let child_size = child.size();
            current_offset = match self.direction {
                Axis::Vertical => {
                    Offset::new(current_offset.x, current_offset.y + child_size.height)
                }
                Axis::Horizontal => {
                    Offset::new(current_offset.x + child_size.width, current_offset.y)
                }
            };
        }
    }
    
    // ... other methods
}
```

---

**Next:** Part 4 - Rendering System & Animation
