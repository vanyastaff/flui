# Research: flui-cli Completion

**Branch**: `001-cli-completion` | **Date**: 2026-02-08

## R1: Android Emulator CLI Output Parsing

**Decision**: Parse `emulator -list-avds` (line-delimited AVD names) and `adb devices -l` (tab-separated serial + state + properties) for listing. Launch via `emulator -avd <name>` as a background process.

**Rationale**: These are the standard Android SDK CLI tools. The output formats are simple and stable. Using `adb devices -l` (with `-l` flag) provides model info alongside device status.

**Alternatives considered**:
- Android Studio API: Requires IDE, not CLI-friendly
- Direct AVD config parsing (`~/.android/avd/`): Fragile, couples to internal format
- gRPC emulator API: Overkill for list/launch

**Key output formats**:
- `emulator -list-avds`: One AVD name per line, no headers
- `adb devices -l`: Header "List of devices attached", then `serial\tstate product:X model:Y transport_id:Z`
- Emulator serial format: `emulator-<port>` (port = 5554, 5556, ...)

**Error patterns to detect**: Lines containing `PANIC:` or `ERROR:` in emulator output.

**Tool discovery**: Use `which` crate to find `emulator` and `adb`, or check `ANDROID_SDK_ROOT`/`ANDROID_HOME` env vars with known subdirectory paths (`emulator/emulator`, `platform-tools/adb`).

## R2: iOS Simulator CLI Output Parsing

**Decision**: Parse `xcrun simctl list devices --json` (structured JSON) for listing. Boot via `xcrun simctl boot <udid>`.

**Rationale**: JSON output is reliable and well-structured. The `simctl` tool is the official Apple interface. Always use `xcrun simctl` rather than direct `simctl` path.

**Alternatives considered**:
- Plain text `simctl list devices`: Requires regex parsing of indented text, fragile
- Xcode automation APIs: Requires Xcode IDE context
- `instruments` CLI: Deprecated

**Key JSON structure**: `{"devices": {"com.apple.CoreSimulator.SimRuntime.iOS-17-0": [{"udid": "...", "name": "...", "state": "Shutdown|Booted", "isAvailable": true, ...}]}}`. Runtime key encodes OS version.

**Error handling**: Boot returns exit code 0 on success, 164 if already booted, 148 for invalid UDID. Parse stderr for error domain/code.

**Platform gate**: All iOS simulator commands are macOS-only. Check `cfg!(target_os = "macos")` at compile time and `which xcrun` at runtime.

## R3: Platform Scaffolding Directory Structures

**Decision**: Create minimal platform directories following Flutter-like conventions. Each platform gets a `platforms/<name>/` directory with a platform-specific config file.

**Rationale**: Flutter uses `android/`, `ios/`, `web/` at project root. FLUI uses `platforms/` subdirectory to keep root clean. Scaffolding is minimal — full build files are generated by `flui-build`.

**Scaffolding per platform**:
- `platforms/android/`: `AndroidManifest.xml` (minimal), `build.gradle` stub
- `platforms/ios/`: `Info.plist` (minimal), project structure placeholder
- `platforms/web/`: `index.html` (basic WASM loader)
- `platforms/windows/`, `platforms/linux/`, `platforms/macos/`: Empty marker directories (desktop builds don't need extra scaffolding)

**Config mutation**: Use existing `FluiConfig` from `config.rs` — `load()`, modify `build.target_platforms`, `save()`. Already fully implemented.

## R4: Template Dependency Strategy

**Decision**: Default to crates.io version specifiers (`flui_app = "0.1"`). Support `--local` flag for path dependencies (`flui_app = { path = "../../crates/flui_app" }`). Embed FLUI version in a `# FLUI Template v{VERSION}` comment in generated `Cargo.toml`.

**Rationale**: Hardcoded `../../crates/` paths only work inside the FLUI workspace. End users install FLUI crates from crates.io. Local mode serves FLUI contributors developing against HEAD.

**Alternatives considered**:
- Git dependencies: Slower, requires network
- Workspace inheritance: Only works if project is inside FLUI workspace
- Auto-detect: Complex, error-prone

**Version source**: Read from the CLI crate's own `CARGO_PKG_VERSION` at compile time via `env!("CARGO_PKG_VERSION")`.

## R5: Hot Reload File Watching

**Decision**: Use `notify-debouncer-mini` crate with 500ms debounce. Watch `src/` recursively and `Cargo.toml`. On change, kill current process, rebuild, and relaunch.

**Rationale**: `notify-debouncer-mini` is lightweight (no file ID tracking needed for rebuild-and-restart). 500ms debounce handles IDE multi-file saves without excessive rebuilds. Full debouncer (`notify-debouncer-full`) is overkill — we don't care about rename tracking.

**Alternatives considered**:
- `notify-debouncer-full`: More features than needed, larger dependency
- Raw `notify` with manual debounce: Reinventing the wheel
- `cargo-watch` as dependency: Too heavy, separate binary
- `watchexec` library: Good but large dependency tree

**New dependencies**: `notify 8.x`, `notify-debouncer-mini` (latest version).

**Process management**: Use `std::process::Child` to track the running app. On file change: `child.kill()` → `cargo build` → `cargo run` (spawn new `Child`). Handle `SIGINT`/`Ctrl+C` to clean up child process.

## R6: DevTools Integration Strategy

**Decision**: Implement a conditional launch that checks for `flui-devtools` crate availability. If available, call its server entry point. If not, display a clear message with instructions.

**Rationale**: `flui-devtools` is currently disabled in the workspace. The CLI should gracefully handle both states. Feature-gating the devtools dependency behind a Cargo feature flag allows the CLI to compile with or without devtools.

**Alternatives considered**:
- Hard dependency on `flui-devtools`: Blocks CLI compilation when devtools is disabled
- Separate binary: Fragments the CLI experience
- Always stub: Wastes a good command name

**Implementation**: Add `flui-devtools` as an optional dependency behind a `devtools` feature flag. When the feature is enabled, `flui devtools` launches the server. When disabled, it prints instructions on how to enable the feature.

## R7: Integration Test Strategy

**Decision**: Use `assert_cmd` with `Command::cargo_bin("flui")` for integration tests. Each test uses `tempfile::TempDir` for isolation. Tests organized by command in separate files under `tests/`.

**Rationale**: `assert_cmd` and `predicates` are already in dev-deps. Following Cargo convention of `tests/` directory. One file per command group keeps tests maintainable.

**Test categories**:
- `cli_create.rs`: Project creation (both templates, invalid names, directory conflicts)
- `cli_doctor.rs`: Doctor output verification (checks for Rust/Cargo detection)
- `cli_completions.rs`: Shell completion generation (bash, zsh, powershell)
- `cli_platform.rs`: Platform list command
- `cli_errors.rs`: Error cases (not-flui-project, invalid args)

**Constraints**: Tests that require Android SDK or Xcode should be `#[cfg_attr(not(feature = "platform-tests"), ignore)]` to avoid CI failures on machines without these tools.
